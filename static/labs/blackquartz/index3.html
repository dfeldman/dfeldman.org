<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlackQuartz 2.0 - CSS Theme Designer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script data-goatcounter="https://dfeldman.goatcounter.com/count" async src="/js/count.js"></script>
    <style>
        :root {
            --sidebar-width: 330px;
            --control-spacing: 8px;
            --bg-color: #f5f5f5;
            --border-color: #ddd;
            --bg-accent: #eee;
            --accent-color: #2271b1;
            --accent-hover: #135e96;
            --text-color: #333;
            --success-color: #00a32a;
            --warning-color: #d63638;
        }

        * {
            box-sizing: border-box;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            height: 100%;
            overflow: hidden;
            color: var(--text-color);
        }

        h2 {
            padding-top: 10px;
            margin: 0;
        }

        #app {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .controls {
            width: var(--sidebar-width);
            overflow-y: auto;
            padding-left: 15px;
            padding-right: 10px;
            background: var(--bg-color);
            border-right: 1px solid var(--border-color);
            position: relative;
        }

        .controls-header {
            position: sticky;
            top: 0;
            background: var(--bg-color);
            padding-bottom: 10px;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            z-index: 10;
        }

        .preview {
            flex: 1;
            position: relative;
            height: 100%;
            overflow: hidden;
        }

        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .control-group h3 {
            margin-top: 0;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .control-group h3 i {
            margin-right: 8px;
        }

        .control-group.collapsed .control-content {
            display: none;
        }

        .control-group h3 .toggle-icon:before {
            content: '▼';
            display: inline-block;
            margin-right: 8px;
            font-size: 10px;
        }

        .control-group.collapsed h3 .toggle-icon:before {
            content: '►';
        }

        label {
            display: block;
            margin-bottom: var(--control-spacing);
            font-size: 14px;
        }

        input,
        select,
        textarea {
            width: 100%;
            padding: 6px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
        }

        textarea {
            min-height: 80px;
            resize: vertical;
        }

        input[type="checkbox"],
        input[type="radio"] {
            width: auto;
            margin-right: 8px;
        }

        .checkbox-label,
        .radio-label {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .checkbox-label input,
        .radio-label input {
            margin-bottom: 0;
        }

        .color-input {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .color-input input[type="color"] {
            width: 40px;
            padding: 2px;
            margin-right: 10px;
            height: 30px;
        }

        .color-input input[type="text"] {
            flex: 1;
            margin-bottom: 0;
        }

        button {
            background: #333;
            color: white;
            border: none;
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover {
            background: #555;
        }

        .export-button {
            display: block;
            width: 100%;
            background: var(--accent-color);
            margin-bottom: 10px;
        }

        .export-button:hover {
            background: var(--accent-hover);
        }

        .flex {
            display: flex;
            gap: 10px;
        }

        .flex>* {
            flex: 1;
        }

        .range-with-value {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .range-with-value input {
            flex: 1;
            margin-right: 10px;
            margin-bottom: 0;
        }

        .range-with-value span {
            min-width: 45px;
            text-align: right;
            font-size: 14px;
        }

        .font-preview {
            margin-top: 5px;
            padding: 8px;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 16px;
            height: 40px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
        }

        .font-search {
            position: relative;
            margin-bottom: 10px;
        }

        .font-search input {
            width: 100%;
            padding-left: 30px;
        }

        .font-search i {
            position: absolute;
            left: 10px;
            top: 9px;
            color: #888;
        }

        .font-results {
            max-height: 200px;
            overflow-y: auto;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 0 0 4px 4px;
            display: none;
            position: absolute;
            width: 100%;
            z-index: 100;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .font-results.active {
            display: block;
        }

        .font-item {
            padding: 8px 10px;
            cursor: pointer;
            font-size: 14px;
        }

        .font-item:hover {
            background-color: var(--bg-accent);
        }

        .font-category {
            padding: 5px 10px;
            background-color: var(--bg-accent);
            font-weight: bold;
            font-size: 12px;
            text-transform: uppercase;
        }

        .tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .tab {
            padding: 8px 12px;
            cursor: pointer;
            background: var(--bg-color);
            font-size: 14px;
        }

        .tab.active {
            border-bottom: 2px solid var(--accent-color);
            font-weight: bold;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .wiki-selector {
            margin-bottom: 15px;
        }

        .controls-footer {
            position: sticky;
            bottom: 0;
            background: var(--bg-color);
            padding-top: 10px;
            margin-top: 10px;
            border-top: 1px solid var(--border-color);
            z-index: 10;
        }

        .preset-button {
            background: #666;
            margin-bottom: 5px;
        }

        .preset-button:hover {
            background: #888;
        }

        .loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 4px solid var(--accent-color);
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .message {
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 4px;
            font-size: 14px;
        }

        .message.success {
            background-color: rgba(0, 163, 42, 0.1);
            border: 1px solid var(--success-color);
            color: var(--success-color);
        }

        .message.error {
            background-color: rgba(214, 54, 56, 0.1);
            border: 1px solid var(--warning-color);
            color: var(--warning-color);
        }

        .wiki-search-results {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-bottom: 15px;
            background: white;
            display: none;
        }

        .wiki-search-results.active {
            display: block;
        }

        .wiki-result-item {
            padding: 8px 10px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
        }

        .wiki-result-item:hover {
            background-color: var(--bg-accent);
        }

        .wiki-result-title {
            font-weight: bold;
        }

        .wiki-result-snippet {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }

        .segmented-control {
            display: flex;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }

        .segmented-control label {
            margin: 0;
            flex: 1;
            text-align: center;
            padding: 6px;
            background: var(--bg-color);
            border-right: 1px solid var(--border-color);
            cursor: pointer;
            font-size: 13px;
        }

        .segmented-control label:last-child {
            border-right: none;
        }

        .segmented-control input[type="radio"] {
            display: none;
        }

        .segmented-control input[type="radio"]:checked+label {
            background: var(--accent-color);
            color: white;
        }

        /* Custom scrollbar */
        .controls::-webkit-scrollbar {
            width: 10px;
        }

        .controls::-webkit-scrollbar-track {
            background: var(--bg-color);
        }

        .controls::-webkit-scrollbar-thumb {
            background: #bbb;
            border-radius: 5px;
        }

        .controls::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            margin-bottom: 10px;
        }

        .color-swatch {
            height: 24px;
            border-radius: 3px;
            cursor: pointer;
            border: 1px solid var(--border-color);
        }

        .image-upload-preview {
            max-width: 100%;
            height: 100px;
            object-fit: cover;
            margin-bottom: 10px;
            background-color: #f1f1f1;
            border: 1px dashed #ccc;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-upload-preview img {
            max-width: 100%;
            max-height: 100px;
            object-fit: contain;
        }

        .nav-link {
            cursor: pointer;
            color: var(--accent-color);
            text-decoration: underline;
            display: inline-block;
            margin-top: 5px;
            font-size: 14px;
        }

        .preview.responsive-mode {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f0f0f0;
        }

        .device-wrapper {
            border: 1px solid #ccc;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            background-color: white;
        }

        .device-desktop {
            width: 90%;
            height: 90%;
        }

        .device-tablet {
            width: 768px;
            height: 1024px;
            max-height: 90%;
        }

        .device-mobile {
            width: 375px;
            height: 667px;
            max-height: 90%;
        }

        .device-wrapper iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Background Editor Modal Styles */
        .background-editor-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 1000px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid #eaeaea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 22px;
            cursor: pointer;
            color: #666;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            max-height: calc(90vh - 130px);
        }

        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid #eaeaea;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .btn {
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn.save {
            background-color: var(--accent-color);
            color: white;
        }

        .btn.save:hover {
            background-color: var(--accent-hover);
        }

        .btn.cancel {
            background-color: #f1f1f1;
            color: #333;
        }

        .btn.cancel:hover {
            background-color: #e1e1e1;
        }

        .btn.small {
            padding: 4px 8px;
            font-size: 12px;
        }

        .background-type-selector {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #eaeaea;
            overflow-x: auto;
            white-space: nowrap;
        }

        .background-type-selector label {
            margin: 0;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 14px;
            border-bottom: 2px solid transparent;
        }

        .background-type-selector input[type="radio"] {
            display: none;
        }

        .background-type-selector input[type="radio"]:checked+label {
            border-bottom-color: var(--accent-color);
            color: var(--accent-color);
            font-weight: bold;
        }

        .color-controls,
        .pattern-controls,
        .texture-controls,
        .image-controls,
        .gradient-controls {
            display: none;
        }

        .color-controls.active,
        .pattern-controls.active,
        .texture-controls.active,
        .image-controls.active,
        .gradient-controls.active {
            display: block;
        }

        .harmony-selector {
            margin-top: 15px;
        }

        .harmony-colors {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .color-swatch {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #ddd;
        }

        .texture-grid,
        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .texture-swatch,
        .pattern-swatch {
            width: 100%;
            height: 80px;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            position: relative;
        }

        .texture-swatch.selected,
        .pattern-swatch.selected {
            border-color: var(--accent-color);
        }

        .pattern-name,
        .texture-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 5px;
            background-color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            text-align: center;
        }

        .gradient-type-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .gradient-type-btn {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            background-color: #f5f5f5;
        }

        .gradient-type-btn.active {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .gradient-stop {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }

        .gradient-stop input[type="color"] {
            width: 40px;
            height: 30px;
            padding: 2px;
        }

        .gradient-stop input[type="range"] {
            flex: 1;
        }

        .gradient-stop .stop-position {
            min-width: 40px;
            text-align: right;
        }

        .gradient-add-stop {
            margin-top: 10px;
        }

        .pattern-colors {
            margin-top: 15px;
        }

        .pattern-color-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        /* Background preview area */
        .background-preview {
            width: 100%;
            height: 200px;
            border-radius: 4px;
            margin: 20px 0;
            border: 1px solid #ddd;
            position: relative;
            overflow: hidden;
        }

        /* Color themes grid */
        .color-themes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .color-theme {
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
        }

        .color-theme:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .color-theme-preview {
            display: flex;
            height: 30px;
        }

        .color-theme-preview div {
            flex: 1;
        }

        .color-theme-name {
            padding: 5px;
            text-align: center;
            font-size: 12px;
            background-color: #f9f9f9;
            border-top: 1px solid #ddd;
        }

        /* Image controls */
        .image-controls .image-input-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .image-controls input[type="file"] {
            display: none;
        }

        .file-name {
            flex: 1;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .image-preview-container {
            width: 100%;
            height: 150px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            background-color: #f9f9f9;
            background-position: center;
            background-size: cover;
            position: relative;
        }

        .image-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .image-controls .control-group {
            margin-bottom: 15px;
        }

        .image-controls .control-group label {
            margin-bottom: 5px;
        }

        /* Font selector improvements */
        .font-selector-container {
            position: relative;
        }

        .font-preview-container {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 16px;
            line-height: 1.5;
            min-height: 100px;
            background-color: white;
        }

        .font-selector-tabs {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }

        .font-selector-tab {
            padding: 8px 12px;
            cursor: pointer;
            margin-right: 5px;
            border-bottom: 2px solid transparent;
        }

        .font-selector-tab.active {
            border-bottom-color: var(--accent-color);
            color: var(--accent-color);
        }

        .font-selector-content {
            display: none;
        }

        .font-selector-content.active {
            display: block;
        }

        .font-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
            padding: 10px 0;
        }

        .font-grid-item {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
        }

        .font-grid-item:hover {
            background-color: #f5f5f5;
        }

        .font-grid-item.selected {
            border-color: var(--accent-color);
            background-color: rgba(34, 113, 177, 0.1);
        }

        .font-pairing {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .font-pairing:hover {
            background-color: #f5f5f5;
        }

        .font-pairing h4 {
            margin: 0 0 5px 0;
        }

        .font-pairing p {
            margin: 0;
            font-size: 14px;
            color: #666;
        }

        .font-pairing-preview {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        .font-pairing-title {
            font-size: 18px;
            margin-bottom: 5px;
        }

        .font-pairing-body {
            font-size: 14px;
        }

        /* New styles for light/dark mode switch */
        .mode-switch {
            display: flex;
            align-items: center;
            margin-left: 15px;
        }

        .mode-switch-label {
            display: inline-block;
            width: 44px;
            height: 24px;
            position: relative;
        }

        .mode-switch-input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .mode-switch-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .mode-switch-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        .mode-switch-input:checked+.mode-switch-slider {
            background-color: var(--accent-color);
        }

        .mode-switch-input:checked+.mode-switch-slider:before {
            transform: translateX(20px);
        }

        .mode-icon {
            margin: 0 5px;
            font-size: 14px;
        }

        /* Dual color picker styles */
        .dual-color-input {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
        }

        .dual-color-row {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .dual-color-row label {
            width: 80px;
            margin-bottom: 0;
        }

        .dual-color-row input[type="color"] {
            width: 40px;
            height: 30px;
        }

        .dual-color-row input[type="text"] {
            flex: 1;
            margin-left: 10px;
        }

        .link-both {
            margin-left: 5px;
            cursor: pointer;
            color: var(--accent-color);
            font-size: 14px;
        }

        .linked {
            color: var(--success-color);
        }
    </style>
</head>

<body>
    <div id="app">
        <editor-controls :theme="theme" :editor-state="editorState" :is-loading="isLoading"
            @update-preview="updatePreview" @toggle-dark-mode="toggleColorMode" @toggle-group="toggleGroup"
            @generate-new-lorem="generateNewLorem" @search-wikipedia="searchWikipedia"
            @select-wiki-article="selectWikiArticle" @fetch-wiki-article="fetchWikiArticleContent"
            @open-background-editor="openBackgroundEditor" @open-font-selector="openFontSelector"
            @open-color-picker="openColorPicker" @export-css="exportCSS" @export-html="exportHTML" @copy-css="copyCSS"
            @export-theme-json="exportThemeJSON" @import-theme-json="importThemeJSON"
            @apply-preset="applyPreset"></editor-controls>

        <theme-preview :theme="theme" :editor-state="editorState" :is-loading="isLoading" ref="preview"></theme-preview>

        <!-- Background Editor Modal -->
        <background-editor v-if="editorState.showBackgroundEditor" :background="editorState.tempBackground"
            :target="editorState.currentBackgroundTarget" :color-mode="editorState.colorMode"
            @save="saveBackgroundSettings" @close="editorState.showBackgroundEditor = false"></background-editor>

        <!-- Font Selector Modal -->
        <font-selector v-if="editorState.showFontSelector" :font-family="editorState.tempFontFamily"
            :target="editorState.fontSelectorTarget" :tab="editorState.fontSelectorTab" :search="editorState.fontSearch"
            @save="saveFontSelection" @close="editorState.showFontSelector = false"
            @set-tab="editorState.fontSelectorTab = $event" @set-search="editorState.fontSearch = $event"
            @select-font="selectFont" @select-pairing="applyFontPairing"></font-selector>

        <!-- Color Picker Modal -->
        <color-picker v-if="editorState.showColorPicker" :color="editorState.tempColor"
            :target="editorState.colorPickerTarget" :mode="editorState.colorMode" @save="saveColorSelection"
            @close="editorState.showColorPicker = false" @set-color="editorState.tempColor = $event"></color-picker>
    </div>

    <!-- Vue Templates -->
    <script type="text/x-template" id="editor-controls-template">
    <div class="controls">
      <div class="controls-header">
        <div style="display: flex; align-items: center; justify-content: space-between;">
          <h2><span style="color:#333">Black</span><span style="color:#2271b1">Quartz</span> <span style="font-size:14px;color:#666">2.0</span></h2>
          <div class="mode-switch">
            <span class="mode-icon"><i class="fas fa-sun"></i></span>
            <label class="mode-switch-label">
              <input type="checkbox" class="mode-switch-input" :checked="editorState.colorMode === 'dark'" @change="toggleDarkMode">
              <span class="mode-switch-slider"></span>
            </label>
            <span class="mode-icon"><i class="fas fa-moon"></i></span>
          </div>
        </div>
        
        <div class="tabs">
          <div 
            :class="['tab', editorState.activeTab === 'content' ? 'active' : '']" 
            @click="editorState.activeTab = 'content'"
          >Content</div>
          <div 
            :class="['tab', editorState.activeTab === 'design' ? 'active' : '']" 
            @click="editorState.activeTab = 'design'"
          >Design</div>
          <div 
            :class="['tab', editorState.activeTab === 'export' ? 'active' : '']" 
            @click="editorState.activeTab = 'export'"
          >Import/Export</div>
        </div>
      </div>
      
      <!-- Content Tab -->
      <div :class="['tab-content', editorState.activeTab === 'content' ? 'active' : '']">
        <responsive-preview-control 
          :responsive-preview="theme.responsivePreview"
        ></responsive-preview-control>
        
        <content-source-control 
          :content="theme.content"
          :wiki-state="editorState.wiki"
          @generate-lorem="onGenerateNewLorem"
          @search-wiki="onSearchWikipedia"
          @select-wiki="onSelectWikiArticle"
          @fetch-wiki="onFetchWikiArticleContent"
        ></content-source-control>
      </div>
      
      <!-- Design Tab -->
      <div :class="['tab-content', editorState.activeTab === 'design' ? 'active' : '']">
        <design-controls 
          :theme="theme"
          :editor-state="editorState"
          :collapsed-groups="editorState.collapsedGroups"
          @toggle-group="onToggleGroup"
          @open-background="onOpenBackgroundEditor"
          @open-font="onOpenFontSelector"
          @open-color="onOpenColorPicker"
        ></design-controls>
      </div>
      
      <!-- Export Tab -->
      <div :class="['tab-content', editorState.activeTab === 'export' ? 'active' : '']">
        <export-controls 
          :theme="theme"
          @export-css="onExportCSS"
          @export-html="onExportHTML"
          @copy-css="onCopyCSS"
          @export-json="onExportThemeJSON"
          @import-json="onImportThemeJSON"
          @apply-preset="onApplyPreset"
        ></export-controls>
      </div>
      
      <div class="controls-footer">
        <button class="export-button" @click="refreshPreview">
          <i class="fas fa-refresh"></i> Refresh Preview
        </button>
      </div>
    </div>
  </script>

    <script type="text/x-template" id="theme-preview-template">
    <div class="preview" :class="{'responsive-mode': theme.responsivePreview.enabled}">
      <div class="device-wrapper" v-if="theme.responsivePreview.enabled" :class="'device-' + theme.responsivePreview.device">
        <iframe ref="previewFrame"></iframe>
      </div>
      <iframe v-else ref="previewFrame"></iframe>
      <div v-if="isLoading" class="loading">
        <div class="spinner"></div>
      </div>
    </div>
  </script>

    <script type="text/x-template" id="responsive-preview-control-template">
    <div class="control-group">
      <h3>Responsive Preview</h3>
      <label class="checkbox-label">
        <input type="checkbox" v-model="responsivePreview.enabled">
        Enable Responsive Preview
      </label>
      <div v-if="responsivePreview.enabled">
        <div class="segmented-control">
          <input type="radio" id="device-desktop" value="desktop" v-model="responsivePreview.device">
          <label for="device-desktop">Desktop</label>
          <input type="radio" id="device-tablet" value="tablet" v-model="responsivePreview.device">
          <label for="device-tablet">Tablet</label>
          <input type="radio" id="device-mobile" value="mobile" v-model="responsivePreview.device">
          <label for="device-mobile">Mobile</label>
        </div>
      </div>
    </div>
  </script>

    <script type="text/x-template" id="content-source-control-template">
    <div class="control-group" :class="{ collapsed: collapsed }">
      <h3 @click="toggleCollapsed">
        <span class="toggle-icon"></span>Content Source
      </h3>
      <div class="control-content" v-show="!collapsed">
        <div class="tabs">
          <div 
            :class="['tab', content.source === 'lorem' ? 'active' : '']" 
            @click="setContentSource('lorem')"
          >Lorem Ipsum</div>
          <div 
            :class="['tab', content.source === 'wiki' ? 'active' : '']" 
            @click="setContentSource('wiki')"
          >Wikipedia</div>
        </div>
        
        <div v-if="content.source === 'lorem'">
          <slider-input 
            label="Paragraphs" 
            v-model="content.loremParagraphs" 
            :min="3" 
            :max="15"
          ></slider-input>
          
          <slider-input 
            label="Images" 
            v-model="content.loremImages" 
            :min="2" 
            :max="8"
          ></slider-input>
          
          <slider-input 
            label="Headings" 
            v-model="content.loremHeadings" 
            :min="2" 
            :max="6"
          ></slider-input>
          
          <button @click="$emit('generate-lorem')">Regenerate Lorem Text</button>
        </div>
        
        <div v-if="content.source === 'wiki'">
          <label>Search Wikipedia</label>
          <div class="font-search">
            <i class="fas fa-search"></i>
            <input 
              type="text" 
              v-model="wikiSearch" 
              @input="onWikiSearchInput"
              placeholder="Search for an article..."
            >
          </div>
          
          <div v-if="wikiState.searching" class="loading" style="position:relative; height:50px;">
            <div class="spinner"></div>
          </div>
          
          <div v-if="wikiState.error" class="message error">
            {{ wikiState.error }}
          </div>
          
          <div :class="['wiki-search-results', wikiState.results.length > 0 ? 'active' : '']">
            <div 
              v-for="result in wikiState.results" 
              :key="result.pageid" 
              class="wiki-result-item"
              @click="onWikiResultClick(result)"
            >
              <div class="wiki-result-title" v-html="result.title"></div>
              <div class="wiki-result-snippet" v-html="result.snippet"></div>
            </div>
          </div>
          
          <div v-if="wikiState.currentArticle">
            <div class="message success">
              <strong>Selected Article:</strong> {{ wikiState.currentArticle.title }}
            </div>
            <button @click="$emit('fetch-wiki')">Load Article Content</button>
          </div>
        </div>
      </div>
    </div>
  </script>

    <script type="text/x-template" id="design-controls-template">
    <div>
      <!-- Background Settings -->
      <control-group 
        title="Background" 
        :collapsed="collapsedGroups.background" 
        @toggle="$emit('toggle-group', 'background')"
      >
        <button @click="$emit('open-background', 'body')" class="export-button" style="margin-bottom: 15px;">
          <i class="fas fa-edit"></i> Edit Body Background
        </button>
        
        <div class="background-preview" :style="getBackgroundPreviewStyle('body')">
          <div class="image-overlay" v-if="theme.backgrounds.body.type === 'image' && theme.backgrounds.body.overlay.enabled" 
              :style="{ backgroundColor: getCurrentColor(theme.backgrounds.body.overlay.color), opacity: theme.backgrounds.body.overlay.opacity }"></div>
        </div>
      </control-group>
      
      <!-- Page Settings -->
      <control-group 
        title="Page" 
        :collapsed="collapsedGroups.page" 
        @toggle="$emit('toggle-group', 'page')"
      >
        <checkbox-input 
          label="Enable Page Background" 
          v-model="theme.page.enabled"
        ></checkbox-input>
        
        <div v-if="theme.page.enabled">
          <button @click="$emit('open-background', 'page')" class="export-button" style="margin: 15px 0;">
            <i class="fas fa-edit"></i> Edit Page Background
          </button>
          
          <div class="background-preview" :style="getBackgroundPreviewStyle('page')">
            <div class="image-overlay" v-if="theme.backgrounds.page.type === 'image' && theme.backgrounds.page.overlay.enabled" 
                :style="{ backgroundColor: getCurrentColor(theme.backgrounds.page.overlay.color), opacity: theme.backgrounds.page.overlay.opacity }"></div>
          </div>
          
          <slider-input 
            label="Shadow Size (px)" 
            v-model="theme.page.shadowSize" 
            :min="0" 
            :max="50"
            :unit="'px'"
          ></slider-input>
          
          <slider-input 
            label="Border Size (px)" 
            v-model="theme.page.borderSize" 
            :min="0" 
            :max="20"
            :unit="'px'"
          ></slider-input>
          
          <dual-color-input 
            label="Border Color" 
            v-model="theme.page.borderColor"
            :color-mode="editorState.colorMode"
            @edit="$emit('open-color', 'page-border')"
          ></dual-color-input>
          
          <label>Page Padding (px)</label>
          <div class="flex">
            <slider-input 
              label="Horizontal" 
              v-model="theme.page.paddingX" 
              :min="10" 
              :max="80"
              :unit="'px'"
            ></slider-input>
            
            <slider-input 
              label="Vertical" 
              v-model="theme.page.paddingY" 
              :min="10" 
              :max="80"
              :unit="'px'"
            ></slider-input>
          </div>
          
          <slider-input 
            label="Width (px)" 
            v-model="theme.page.maxWidth" 
            :min="600" 
            :max="1400"
            :step="50"
            :unit="'px'"
          ></slider-input>
          
          <slider-input 
            label="Border Radius (px)" 
            v-model="theme.page.borderRadius" 
            :min="0" 
            :max="30"
            :unit="'px'"
          ></slider-input>
        </div>
    </control-group>

<!-- Image Settings -->
<control-group 
  title="Images" 
  :collapsed="collapsedGroups.images" 
  @toggle="$emit('toggle-group', 'images')"
>
  <h4>General Image Settings</h4>
  
  <!-- Image Size Controls -->
  <label>Image Max Width (%)</label>
  <div class="range-with-value">
    <input 
      type="range" 
      v-model.number="theme.images.maxWidth" 
      min="50" 
      max="100" 
      step="5"
    >
    <span>{{ theme.images.maxWidth }}%</span>
  </div>
  
  <!-- Alignment Settings -->
  <label>Default Alignment</label>
  <select v-model="theme.images.defaultAlign">
    <option value="center">Center</option>
    <option value="left">Left</option>
    <option value="right">Right</option>
  </select>
  
  <!-- Border Controls -->
  <h4>Border</h4>
  <label>Border Size (px)</label>
  <div class="range-with-value">
    <input 
      type="range" 
      v-model.number="theme.images.borderSize" 
      min="0" 
      max="20"
    >
    <span>{{ theme.images.borderSize }}px</span>
  </div>
  
  <label>Border Style</label>
  <select v-model="theme.images.borderStyle">
    <option value="solid">Solid</option>
    <option value="dashed">Dashed</option>
    <option value="dotted">Dotted</option>
    <option value="double">Double</option>
    <option value="groove">Groove</option>
    <option value="ridge">Ridge</option>
    <option value="inset">Inset</option>
    <option value="outset">Outset</option>
  </select>
  
  <dual-color-input 
    label="Border Color" 
    v-model="theme.images.borderColor"
    :color-mode="editorState.colorMode"
    @edit="$emit('open-color', 'image-border')"
  ></dual-color-input>
  
  <label>Border Radius (px)</label>
  <div class="range-with-value">
    <input 
      type="range" 
      v-model.number="theme.images.borderRadius" 
      min="0" 
      max="50"
    >
    <span>{{ theme.images.borderRadius }}px</span>
  </div>
  
  <!-- Shadow Controls -->
  <h4>Shadow</h4>
  <checkbox-input 
    label="Enable Shadow" 
    v-model="theme.images.shadowEnabled"
  ></checkbox-input>
  
  <div v-if="theme.images.shadowEnabled">
    <label>Shadow Size (px)</label>
    <div class="range-with-value">
      <input 
        type="range" 
        v-model.number="theme.images.shadowSize" 
        min="0" 
        max="50"
      >
      <span>{{ theme.images.shadowSize }}px</span>
    </div>
    
    <label>Shadow Blur (px)</label>
    <div class="range-with-value">
      <input 
        type="range" 
        v-model.number="theme.images.shadowBlur" 
        min="0" 
        max="50"
      >
      <span>{{ theme.images.shadowBlur }}px</span>
    </div>
    
    <label>Shadow Opacity (%)</label>
    <div class="range-with-value">
      <input 
        type="range" 
        v-model.number="theme.images.shadowOpacity" 
        min="0" 
        max="100"
      >
      <span>{{ theme.images.shadowOpacity }}%</span>
    </div>
  </div>
  
  <!-- Spacing Controls -->
  <h4>Spacing</h4>
  <label>Margin Above (px)</label>
  <div class="range-with-value">
    <input 
      type="range" 
      v-model.number="theme.images.marginTop" 
      min="0" 
      max="50"
    >
    <span>{{ theme.images.marginTop }}px</span>
  </div>
  
  <label>Margin Below (px)</label>
  <div class="range-with-value">
    <input 
      type="range" 
      v-model.number="theme.images.marginBottom" 
      min="0" 
      max="50"
    >
    <span>{{ theme.images.marginBottom }}px</span>
  </div>
  
  <label>Padding (px)</label>
  <div class="range-with-value">
    <input 
      type="range" 
      v-model.number="theme.images.padding" 
      min="0" 
      max="30"
    >
    <span>{{ theme.images.padding }}px</span>
  </div>
  
  <!-- Caption Controls -->
  <h4>Caption</h4>
  <checkbox-input 
    label="Enable Caption" 
    v-model="theme.images.captionEnabled"
  ></checkbox-input>
  
  <div v-if="theme.images.captionEnabled">
    <label>Caption Position</label>
    <select v-model="theme.images.captionPosition">
      <option value="below">Below Image</option>
      <option value="overlay">Overlay (Bottom)</option>
      <option value="inside-border">Inside Border</option>
    </select>
    
    <label>Caption Font Family</label>
    <select v-model="theme.images.captionFont">
      <option value="inherit">Same as Body</option>
      <option value="headings">Same as Headings</option>
      <option value="monospace">Monospace</option>
      <option value="serif">Serif</option>
      <option value="sans-serif">Sans-serif</option>
    </select>
    
    <label>Caption Size (px)</label>
    <div class="range-with-value">
      <input 
        type="range" 
        v-model.number="theme.images.captionSize" 
        min="10" 
        max="20"
      >
      <span>{{ theme.images.captionSize }}px</span>
    </div>
    
    <label>Caption Style</label>
    <select v-model="theme.images.captionStyle">
      <option value="normal">Normal</option>
      <option value="italic">Italic</option>
      <option value="bold">Bold</option>
      <option value="bold-italic">Bold Italic</option>
    </select>
    
    <label>Caption Alignment</label>
    <select v-model="theme.images.captionAlign">
      <option value="left">Left</option>
      <option value="center">Center</option>
      <option value="right">Right</option>
    </select>
    
    <dual-color-input 
      label="Caption Color" 
      v-model="theme.images.captionColor"
      :color-mode="editorState.colorMode"
      @edit="$emit('open-color', 'image-caption')"
    ></dual-color-input>
    
    <label>Caption Background</label>
    <checkbox-input 
      label="Enable Caption Background" 
      v-model="theme.images.captionBgEnabled"
    ></checkbox-input>
    
    <div v-if="theme.images.captionBgEnabled">
      <dual-color-input 
        label="Background Color" 
        v-model="theme.images.captionBgColor"
        :color-mode="editorState.colorMode"
        @edit="$emit('open-color', 'caption-bg')"
      ></dual-color-input>
      
      <label>Background Opacity (%)</label>
      <div class="range-with-value">
        <input 
          type="range" 
          v-model.number="theme.images.captionBgOpacity" 
          min="0" 
          max="100"
        >
        <span>{{ theme.images.captionBgOpacity }}%</span>
      </div>
    </div>
  </div>
  
  <!-- Image Effects -->
  <h4>Image Effects</h4>
  <label>Brightness (%)</label>
  <div class="range-with-value">
    <input 
      type="range" 
      v-model.number="theme.images.brightness" 
      min="50" 
      max="150"
    >
    <span>{{ theme.images.brightness }}%</span>
  </div>
  
  <label>Contrast (%)</label>
  <div class="range-with-value">
    <input 
      type="range" 
      v-model.number="theme.images.contrast" 
      min="50" 
      max="150"
    >
    <span>{{ theme.images.contrast }}%</span>
  </div>
  
  <label>Saturation (%)</label>
  <div class="range-with-value">
    <input 
      type="range" 
      v-model.number="theme.images.saturation" 
      min="0" 
      max="200"
    >
    <span>{{ theme.images.saturation }}%</span>
  </div>
  
  <label>Hover Effect</label>
  <select v-model="theme.images.hoverEffect">
    <option value="none">None</option>
    <option value="zoom">Zoom</option>
    <option value="brighten">Brighten</option>
    <option value="saturate">Saturate</option>
    <option value="blur">Blur Edges</option>
    <option value="shadow">Enhanced Shadow</option>
  </select>
</control-group>

<!-- Image Links Settings -->
<control-group 
  title="Image Links" 
  :collapsed="collapsedGroups.imageLinks" 
  @toggle="$emit('toggle-group', 'imageLinks')"
>
  <h4>Layout</h4>
  <label>Display Layout</label>
  <select v-model="theme.imageLinks.layout">
    <option value="grid">Grid</option>
    <option value="carousel">Carousel</option>
    <option value="list">List</option>
  </select>
  
  <!-- Grid Settings -->
  <div v-if="theme.imageLinks.layout === 'grid'">
    <label>Grid Style</label>
    <select v-model="theme.imageLinks.displayStyle">
      <option value="standard">Standard Grid</option>
      <option value="masonry">Masonry</option>
    </select>
    
    <label>Items Per Row</label>
    <slider-input 
      v-model="theme.imageLinks.itemsPerRow" 
      :min="1" 
      :max="6"
    ></slider-input>
    
    <label>Grid Gap (px)</label>
    <slider-input 
      v-model="theme.imageLinks.gap" 
      :min="0" 
      :max="40"
      :unit="'px'"
    ></slider-input>
    
    <label>Aspect Ratio</label>
    <select v-model="theme.imageLinks.aspectRatio">
      <option value="1:1">Square (1:1)</option>
      <option value="4:3">Standard (4:3)</option>
      <option value="16:9">Widescreen (16:9)</option>
      <option value="2:3">Portrait (2:3)</option>
      <option value="auto">Auto (Natural)</option>
    </select>
  </div>
  
  <!-- Carousel Settings -->
  <div v-if="theme.imageLinks.layout === 'carousel'">
    <label>Visible Items</label>
    <slider-input 
      v-model="theme.imageLinks.itemsPerRow" 
      :min="1" 
      :max="5"
    ></slider-input>
    
    <label>Spacing Between Items (px)</label>
    <slider-input 
      v-model="theme.imageLinks.spacing" 
      :min="0" 
      :max="40"
      :unit="'px'"
    ></slider-input>
    
    <label>Auto Scroll</label>
    <checkbox-input 
      label="Enable Auto Scroll" 
      v-model="theme.imageLinks.carousel.autoScroll"
    ></checkbox-input>
    
    <div v-if="theme.imageLinks.carousel.autoScroll">
      <label>Scroll Speed (seconds)</label>
      <slider-input 
        v-model="theme.imageLinks.carousel.scrollSpeed" 
        :min="1" 
        :max="10"
        :step="0.5"
        :unit="'s'"
      ></slider-input>
    </div>
    
    <label>Show Navigation</label>
    <checkbox-input 
      label="Show Arrows" 
      v-model="theme.imageLinks.carousel.showArrows"
    ></checkbox-input>
    
    <checkbox-input 
      label="Show Pagination Dots" 
      v-model="theme.imageLinks.carousel.showDots"
    ></checkbox-input>
    
    <checkbox-input 
      label="Infinite Loop" 
      v-model="theme.imageLinks.carousel.infiniteLoop"
    ></checkbox-input>
    
    <label>Transition Effect</label>
    <select v-model="theme.imageLinks.carousel.transition">
      <option value="slide">Slide</option>
      <option value="fade">Fade</option>
      <option value="zoom">Zoom</option>
    </select>
  </div>
  
  <!-- List Settings -->
  <div v-if="theme.imageLinks.layout === 'list'">
    <label>Image Position</label>
    <segmented-control 
      v-model="theme.imageLinks.imagePosition"
      :options="[
        { value: 'left', label: 'Left' },
        { value: 'right', label: 'Right' }
      ]"
    ></segmented-control>
    
    <label>Image Width (px)</label>
    <slider-input 
      v-model="theme.imageLinks.list.imageWidth" 
      :min="60" 
      :max="200"
      :unit="'px'"
    ></slider-input>
    
    <label>Image Height (px)</label>
    <slider-input 
      v-model="theme.imageLinks.list.imageHeight" 
      :min="40" 
      :max="150"
      :unit="'px'"
    ></slider-input>
    
    <label>Spacing Between Items (px)</label>
    <slider-input 
      v-model="theme.imageLinks.spacing" 
      :min="5" 
      :max="40"
      :unit="'px'"
    ></slider-input>
    
    <checkbox-input 
      label="Show Divider Between Items" 
      v-model="theme.imageLinks.list.showDivider"
    ></checkbox-input>
    
    <div v-if="theme.imageLinks.list.showDivider">
      <label>Divider Color</label>
      <dual-color-input 
        v-model="theme.imageLinks.list.dividerColor"
        :color-mode="editorState.colorMode"
      ></dual-color-input>
    </div>
  </div>
  
  <h4>Styling</h4>
  
  <label>Border Size (px)</label>
  <slider-input 
    v-model="theme.imageLinks.borderSize" 
    :min="0" 
    :max="10"
    :unit="'px'"
  ></slider-input>
  
  <div v-if="theme.imageLinks.borderSize > 0">
    <label>Border Color</label>
    <dual-color-input 
      v-model="theme.imageLinks.borderColor"
      :color-mode="editorState.colorMode"
    ></dual-color-input>
    
    <label>Border Style</label>
    <select v-model="theme.imageLinks.borderStyle">
      <option value="solid">Solid</option>
      <option value="dashed">Dashed</option>
      <option value="dotted">Dotted</option>
      <option value="double">Double</option>
    </select>
  </div>
  
  <label>Border Radius (px)</label>
  <slider-input 
    v-model="theme.imageLinks.borderRadius" 
    :min="0" 
    :max="30"
    :unit="'px'"
  ></slider-input>
  
  <label>Shadow</label>
  <select v-model="theme.imageLinks.shadowStyle">
    <option value="none">None</option>
    <option value="light">Light</option>
    <option value="medium">Medium</option>
    <option value="dark">Dark</option>
    <option value="custom">Custom</option>
  </select>
  
  <div v-if="theme.imageLinks.shadowStyle === 'custom'">
    <label>Shadow Size (px)</label>
    <slider-input 
      v-model="theme.imageLinks.shadowSize" 
      :min="0" 
      :max="40"
      :unit="'px'"
    ></slider-input>
    
    <label>Shadow Blur (px)</label>
    <slider-input 
      v-model="theme.imageLinks.shadowBlur" 
      :min="0" 
      :max="40"
      :unit="'px'"
    ></slider-input>
    
    <label>Shadow Color</label>
    <dual-color-input 
      v-model="theme.imageLinks.shadowColor"
      :color-mode="editorState.colorMode"
    ></dual-color-input>
    
    <slider-input 
      label="Shadow Opacity (%)" 
      v-model="theme.imageLinks.shadowOpacity" 
      :min="0" 
      :max="100"
      :unit="'%'"
    ></slider-input>
  </div>
  
  <label>Background Color</label>
  <dual-color-input 
    v-model="theme.imageLinks.backgroundColor"
    :color-mode="editorState.colorMode"
  ></dual-color-input>
  
  <h4>Image Options</h4>
  
  <label>Image Fit</label>
  <select v-model="theme.imageLinks.imageFit">
    <option value="cover">Cover</option>
    <option value="contain">Contain</option>
    <option value="fill">Fill</option>
    <option value="none">None</option>
  </select>
  
  <slider-input 
    label="Image Opacity (%)" 
    v-model="theme.imageLinks.imageOpacity" 
    :min="20" 
    :max="100"
    :unit="'%'"
  ></slider-input>
  
  <h4>Caption Options</h4>
  
  <label>Caption Position</label>
  <select v-model="theme.imageLinks.captionPosition">
    <option value="below">Below Image</option>
    <option value="overlay-bottom">Overlay (Bottom)</option>
    <option value="overlay-top">Overlay (Top)</option>
    <option value="hover">Show on Hover</option>
  </select>
  
  <label>Caption Background</label>
  <dual-color-input 
    v-model="theme.imageLinks.captionBackground"
    :color-mode="editorState.colorMode"
  ></dual-color-input>
  
  <slider-input 
    label="Caption Background Opacity (%)" 
    v-model="theme.imageLinks.captionOpacity" 
    :min="0" 
    :max="100"
    :unit="'%'"
  ></slider-input>
  
  <label>Caption Text Color</label>
  <dual-color-input 
    v-model="theme.imageLinks.captionColor"
    :color-mode="editorState.colorMode"
  ></dual-color-input>
  
  <label>Caption Font</label>
  <select v-model="theme.imageLinks.captionFont">
    <option value="inherit">Same as Body</option>
    <option value="heading">Same as Headings</option>
    <option value="custom">Custom</option>
  </select>
  
  <div v-if="theme.imageLinks.captionFont === 'custom'">
    <button @click="$emit('open-font', 'image-caption')" class="export-button" style="margin: 10px 0;">
      <i class="fas fa-font"></i> Select Caption Font
    </button>
  </div>
  
  <label>Caption Size (px)</label>
  <slider-input 
    v-model="theme.imageLinks.captionSize" 
    :min="10" 
    :max="24"
    :unit="'px'"
  ></slider-input>
  
  <label>Caption Text Style</label>
  <select v-model="theme.imageLinks.captionTextStyle">
    <option value="normal">Normal</option>
    <option value="italic">Italic</option>
    <option value="uppercase">UPPERCASE</option>
    <option value="smallcaps">Small Caps</option>
  </select>
  
  <label>Caption Alignment</label>
  <segmented-control 
    v-model="theme.imageLinks.captionAlignment"
    :options="[
      { value: 'left', label: 'Left' },
      { value: 'center', label: 'Center' },
      { value: 'right', label: 'Right' }
    ]"
  ></segmented-control>
  
  <label>Caption Padding (px)</label>
  <slider-input 
    v-model="theme.imageLinks.captionPadding" 
    :min="0" 
    :max="20"
    :unit="'px'"
  ></slider-input>
  
  <h4>Hover Effects</h4>
  
  <label>Image Hover Effect</label>
  <select v-model="theme.imageLinks.imageHoverEffect">
    <option value="none">None</option>
    <option value="zoom">Zoom In</option>
    <option value="zoom-out">Zoom Out</option>
    <option value="brighten">Brighten</option>
    <option value="darken">Darken</option>
    <option value="saturate">Saturate</option>
    <option value="desaturate">Desaturate</option>
    <option value="blur">Blur</option>
    <option value="grayscale">Grayscale</option>
    <option value="sepia">Sepia</option>
  </select>
  
  <label>Container Hover Effect</label>
  <select v-model="theme.imageLinks.hoverEffect">
    <option value="none">None</option>
    <option value="lift">Lift Up</option>
    <option value="sink">Sink Down</option>
    <option value="glow">Glow</option>
    <option value="shadow">Shadow Increase</option>
    <option value="border">Border Highlight</option>
  </select>
  
  <checkbox-input 
    label="Show Overlay on Hover" 
    v-model="theme.imageLinks.showOverlayOnHover"
  ></checkbox-input>
  
  <div v-if="theme.imageLinks.showOverlayOnHover">
    <label>Overlay Color</label>
    <dual-color-input 
      v-model="theme.imageLinks.overlayColor"
      :color-mode="editorState.colorMode"
    ></dual-color-input>
    
    <slider-input 
      label="Overlay Opacity (%)" 
      v-model="theme.imageLinks.overlayOpacity" 
      :min="0" 
      :max="100"
      :unit="'%'"
    ></slider-input>
    
    <label>Overlay Content</label>
    <select v-model="theme.imageLinks.overlayContent">
      <option value="none">None</option>
      <option value="caption">Caption</option>
      <option value="icon">Icon</option>
      <option value="both">Both</option>
    </select>
  </div>
  
  <label>Caption Hover Color</label>
  <dual-color-input 
    v-model="theme.imageLinks.captionHoverColor"
    :color-mode="editorState.colorMode"
  ></dual-color-input>
  
  <label>Text Hover Effect</label>
  <select v-model="theme.imageLinks.textHoverEffect">
    <option value="none">None</option>
    <option value="underline">Underline</option>
    <option value="color">Color Change</option>
    <option value="bold">Bold</option>
  </select>
  
  <h4>Transition</h4>
  <slider-input 
    label="Hover Transition Speed (seconds)" 
    v-model="theme.imageLinks.transitionSpeed" 
    :min="0" 
    :max="1"
    :step="0.1"
    :unit="'s'"
  ></slider-input>
</control-group>
      <!-- Typography Settings -->
      <control-group 
        title="Typography" 
        :collapsed="collapsedGroups.typography" 
        @toggle="$emit('toggle-group', 'typography')"
      >
        <button @click="$emit('open-font', 'body')" class="export-button" style="margin-bottom: 15px;">
          <i class="fas fa-font"></i> Select Body Font
        </button>
        
        <div class="font-preview" :style="{ fontFamily: theme.type.bodyFont }">
          {{ theme.type.bodyFont.split(',')[0].replace(/'/g, '') }} - The quick brown fox jumps over the lazy dog
        </div>
        
        <button @click="$emit('open-font', 'heading')" class="export-button" style="margin: 15px 0;">
          <i class="fas fa-heading"></i> Select Heading Font
        </button>
        
        <div class="font-preview" :style="{ fontFamily: theme.type.headingFont }">
          {{ theme.type.headingFont.split(',')[0].replace(/'/g, '') }} - The quick brown fox jumps over the lazy dog
        </div>
        
        <slider-input 
          label="Line Height" 
          v-model="theme.type.lineHeight" 
          :min="1" 
          :max="2"
          :step="0.1"
        ></slider-input>
        
        <h4>Text Color</h4>
        <button @click="$emit('open-color', 'text')" class="export-button" style="margin-bottom: 15px;">
          <i class="fas fa-palette"></i> Choose Text Color
        </button>
        
        <dual-color-input 
          label="Text Color" 
          v-model="theme.type.textColor"
          :color-mode="editorState.colorMode"
        ></dual-color-input>
        
        <div>
          <label>Text Size (px)</label>
          <input type="number" min="12" max="24" v-model.number="theme.type.textSize">
        </div>
        
        <h4>Title Typography</h4>
        <button @click="$emit('open-color', 'title')" class="export-button" style="margin-bottom: 15px;">
          <i class="fas fa-palette"></i> Choose Title Color
        </button>
        
        <dual-color-input 
          label="Title Color" 
          v-model="theme.type.titleColor"
          :color-mode="editorState.colorMode"
        ></dual-color-input>
        
        <div>
          <label>Title Size (px)</label>
          <input type="number" min="16" max="72" v-model.number="theme.type.titleSize">
        </div>
        
        <div>
          <label>Title Style</label>
          <select v-model="theme.type.titleStyle">
            <option value="normal">Normal</option>
            <option value="underline">Underline</option>
            <option value="highlight">Highlight</option>
            <option value="bordered">Bordered</option>
            <option value="shadow">Shadow</option>
            <option value="gradient">Gradient Text</option>
          </select>
        </div>
        
        <div>
          <label>Title Alignment</label>
          <segmented-control 
            v-model="theme.type.titleAlign"
            :options="[
              { value: 'left', label: 'Left' },
              { value: 'center', label: 'Center' },
              { value: 'right', label: 'Right' }
            ]"
          ></segmented-control>
        </div>
        
        <label>Title Padding (px)</label>
        <div class="flex">
          <slider-input 
            label="Horizontal" 
            v-model="theme.type.titlePaddingX" 
            :min="0" 
            :max="60"
            :unit="'px'"
          ></slider-input>
          
          <slider-input 
            label="Vertical" 
            v-model="theme.type.titlePaddingY" 
            :min="0" 
            :max="60"
            :unit="'px'"
          ></slider-input>
        </div>
        
        <slider-input 
          label="Space Below Title (px)" 
          v-model="theme.type.titleSpaceBelow" 
          :min="10" 
          :max="60"
          :unit="'px'"
        ></slider-input>
        
        <h4>Heading Typography</h4>
        <button @click="$emit('open-color', 'heading')" class="export-button" style="margin-bottom: 15px;">
          <i class="fas fa-palette"></i> Choose Heading Color
        </button>
        
        <dual-color-input 
          label="Heading Color" 
          v-model="theme.type.headingColor"
          :color-mode="editorState.colorMode"
        ></dual-color-input>
        
        <div>
          <label>Heading Size (px)</label>
          <input type="number" min="14" max="48" v-model.number="theme.type.headingSize">
        </div>
        
        <div>
          <label>Heading Style</label>
          <select v-model="theme.type.headingStyle">
            <option value="normal">Normal</option>
            <option value="underline">Underline</option>
            <option value="highlight">Highlight</option>
            <option value="leftBorder">Left Border</option>
            <option value="gradient">Gradient Text</option>
          </select>
        </div>
        
        <slider-input 
          label="Space Above Heading (px)" 
          v-model="theme.type.headingSpaceAbove" 
          :min="10" 
          :max="50"
          :unit="'px'"
        ></slider-input>
        
        <slider-input 
          label="Space Below Heading (px)" 
          v-model="theme.type.headingSpaceBelow" 
          :min="10" 
          :max="40"
          :unit="'px'"
        ></slider-input>
        
        <h4>Links</h4>
        <div class="flex">
          <div>
            <label>Color</label>
            <dual-color-input 
              v-model="theme.type.linkColor"
              :color-mode="editorState.colorMode"
            ></dual-color-input>
          </div>
          <div>
            <label>Hover Color</label>
            <dual-color-input 
              v-model="theme.type.linkHoverColor"
              :color-mode="editorState.colorMode"
            ></dual-color-input>
          </div>
        </div>
        
        <checkbox-input 
          label="Underline Links" 
          v-model="theme.type.linkUnderline"
        ></checkbox-input>
        
        <div>
          <label>Hover Effect</label>
          <select v-model="theme.type.linkHoverEffect">
            <option value="none">None</option>
            <option value="underline">Underline on Hover</option>
            <option value="highlight">Highlight on Hover</option>
            <option value="bold">Bold on Hover</option>
          </select>
        </div>
      </control-group>
      
      <!-- Hero Panel -->
      <control-group 
        title="Hero Panel" 
        :collapsed="collapsedGroups.hero" 
        @toggle="$emit('toggle-group', 'hero')"
      >
        <checkbox-input 
          label="Enable Hero Panel" 
          v-model="theme.hero.enabled"
        ></checkbox-input>
        
        <div v-if="theme.hero.enabled">
          <button @click="$emit('open-background', 'hero')" class="export-button" style="margin: 15px 0;">
            <i class="fas fa-edit"></i> Edit Hero Background
          </button>
          
          <div class="background-preview" :style="getBackgroundPreviewStyle('hero')">
            <div class="image-overlay" v-if="theme.backgrounds.hero.type === 'image' && theme.backgrounds.hero.overlay.enabled" 
                :style="{ backgroundColor: getCurrentColor(theme.backgrounds.hero.overlay.color), opacity: theme.backgrounds.hero.overlay.opacity }"></div>
          </div>
          
          <label>Padding (px)</label>
          <div class="flex">
            <slider-input 
              label="Horizontal" 
              v-model="theme.hero.paddingX" 
              :min="20" 
              :max="100"
              :unit="'px'"
            ></slider-input>
            
            <slider-input 
              label="Vertical" 
              v-model="theme.hero.paddingY" 
              :min="20" 
              :max="100"
              :unit="'px'"
            ></slider-input>
          </div>
          
          <slider-input 
            label="Border Radius (px)" 
            v-model="theme.hero.borderRadius" 
            :min="0" 
            :max="30"
            :unit="'px'"
          ></slider-input>
          
          <div>
            <label>Title Text Effect</label>
            <select v-model="theme.hero.titleEffect">
              <option value="none">None</option>
              <option value="shadow">Text Shadow</option>
              <option value="glow">Glowing</option>
              <option value="outline">Outline</option>
              <option value="contrast">High Contrast</option>
            </select>
          </div>
        </div>
      </control-group>
      
      <!-- More controls for other sections -->
    </div>
  </script>

    <script type="text/x-template" id="export-controls-template">
    <div>
      <div class="control-group">
        <h3>Export Options</h3>
        <button class="export-button" @click="$emit('export-css')">Export CSS</button>
        <button class="export-button" @click="$emit('export-html')">Export HTML Demo</button>
        <button class="export-button" @click="$emit('copy-css')">Copy CSS to Clipboard</button>
        <button class="export-button" @click="$emit('export-json')">Export Theme as JSON</button>
        <button class="export-button" @click="$emit('import-json')">Import Theme from JSON</button>
      </div>
      
      <div class="control-group">
        <h3>Theme Presets</h3>
        <button class="preset-button" @click="$emit('apply-preset', 'modern')">Modern Minimal</button>
        <button class="preset-button" @click="$emit('apply-preset', 'dark')">Dark Mode</button>
        <button class="preset-button" @click="$emit('apply-preset', 'newspaper')">Newspaper</button>
        <button class="preset-button" @click="$emit('apply-preset', 'magazine')">Magazine</button>
        <button class="preset-button" @click="$emit('apply-preset', 'colorful')">Colorful</button>
        <button class="preset-button" @click="$emit('apply-preset', 'elegant')">Elegant Serif</button>
        <button class="preset-button" @click="$emit('apply-preset', 'minimal')">Ultra Minimal</button>
        <button class="preset-button" @click="$emit('apply-preset', 'retro')">Retro Vibes</button>
        <!-- Professional Themes -->
        <button class="preset-button" @click="$emit('apply-preset', 'corporate')">Corporate</button>
        <button class="preset-button" @click="$emit('apply-preset', 'tech')">Tech Terminal</button>
        <button class="preset-button" @click="$emit('apply-preset', 'medical')">Medical Clean</button>
        <button class="preset-button" @click="$emit('apply-preset', 'legal')">Legal Brief</button>
        <button class="preset-button" @click="$emit('apply-preset', 'finance')">Finance Pro</button>
        <!-- More presets... -->
      </div>
    </div>
  </script>

    <script type="text/x-template" id="background-editor-template">
    <div class="background-editor-modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3>Background Editor - {{ getBackgroundEditorTitle() }}</h3>
          <button class="close-btn" @click="$emit('close')">×</button>
        </div>
        
        <div class="modal-body">
          <!-- Background Type Selection -->
          <div class="background-type-selector">
            <input type="radio" id="bg-type-color" value="color" v-model="background.type">
            <label for="bg-type-color">Solid Color</label>
            
            <input type="radio" id="bg-type-gradient" value="gradient" v-model="background.type">
            <label for="bg-type-gradient">Gradient</label>
            
            <input type="radio" id="bg-type-pattern" value="pattern" v-model="background.type">
            <label for="bg-type-pattern">Pattern</label>
            
            <input type="radio" id="bg-type-texture" value="texture" v-model="background.type">
            <label for="bg-type-texture">Texture</label>
            
            <input type="radio" id="bg-type-image" value="image" v-model="background.type">
            <label for="bg-type-image">Image</label>
          </div>
          
          <!-- Background Preview -->
          <div class="background-preview" :style="getTempBackgroundStyle()">
            <div class="image-overlay" v-if="background.type === 'image' && background.overlay.enabled" 
                :style="{ backgroundColor: getCurrentColor(background.overlay.color), opacity: background.overlay.opacity }"></div>
          </div>
          
          <!-- Background Type-specific controls -->
          <div :class="['color-controls', background.type === 'color' ? 'active' : '']">
            <h4>Solid Color</h4>
            <div class="dual-color-input">
              <div class="dual-color-row">
                <label>Light Mode</label>
                <input type="color" v-model="background.color.light">
                <input type="text" v-model="background.color.light">
                <span class="link-both" :class="{ linked: colorLinked }" @click="toggleColorLink">
                  <i class="fas" :class="colorLinked ? 'fa-link' : 'fa-unlink'"></i>
                </span>
              </div>
              <div class="dual-color-row">
                <label>Dark Mode</label>
                <input type="color" v-model="background.color.dark" :disabled="colorLinked">
                <input type="text" v-model="background.color.dark" :disabled="colorLinked">
              </div>
            </div>
            
            <h4>Color Themes</h4>
            <div class="color-themes-grid">
              <div 
                v-for="theme in colorThemes" 
                :key="theme.name" 
                class="color-theme" 
                @click="applyColorTheme(theme, 'color')"
              >
                <div class="color-theme-preview">
                  <div v-for="color in theme.colors" :key="color" :style="{ backgroundColor: color }"></div>
                </div>
                <div class="color-theme-name">{{ theme.name }}</div>
              </div>
            </div>
          </div>
          
          <!-- Gradient Controls -->
<!-- Gradient Controls -->
<div :class="['gradient-controls', background.type === 'gradient' ? 'active' : '']">
    <h4>Gradient Type</h4>
    <div class="gradient-type-selector">
      <div 
        :class="['gradient-type-btn', background.gradient.type === 'linear' ? 'active' : '']" 
        @click="background.gradient.type = 'linear'"
      >Linear</div>
      <div 
        :class="['gradient-type-btn', background.gradient.type === 'radial' ? 'active' : '']" 
        @click="background.gradient.type = 'radial'"
      >Radial</div>
      <div 
        :class="['gradient-type-btn', background.gradient.type === 'conic' ? 'active' : '']" 
        @click="background.gradient.type = 'conic'"
      >Conic</div>
    </div>
    
    <div v-if="background.gradient.type === 'linear'">
      <h4>Angle (degrees)</h4>
      <div class="range-with-value">
        <input 
          type="range" 
          min="0" 
          max="360" 
          step="1" 
          v-model.number="background.gradient.angle"
        >
        <span>{{ background.gradient.angle }}°</span>
      </div>
    </div>
    
    <h4>Gradient Stops</h4>
    <div 
      v-for="(stop, index) in background.gradient.stops" 
      :key="index" 
      class="gradient-stop"
    >
      <div class="dual-color-input">
        <div class="dual-color-row">
          <input type="color" v-model="stop.color.light">
          <input type="text" v-model="stop.color.light">
        </div>
        <div class="dual-color-row" v-if="!colorLinked">
          <input type="color" v-model="stop.color.dark">
          <input type="text" v-model="stop.color.dark">
        </div>
      </div>
      
      <input 
        type="range" 
        min="0" 
        max="100" 
        step="1" 
        v-model.number="stop.position"
      >
      <span class="stop-position">{{ stop.position }}%</span>
      
      <button 
        class="btn small" 
        @click="background.gradient.stops.splice(index, 1)" 
        v-if="background.gradient.stops.length > 2"
      >
        <i class="fas fa-times"></i>
      </button>
    </div>
    
    <button 
      class="btn gradient-add-stop" 
      @click="addGradientStop" 
      v-if="background.gradient.stops.length < 5"
    >
      Add Color Stop
    </button>
    
    <h4>Color Themes</h4>
    <div class="color-themes-grid">
      <div 
        v-for="theme in colorThemes" 
        :key="theme.name" 
        class="color-theme" 
        @click="applyColorTheme(theme, 'gradient')"
      >
        <div class="color-theme-preview">
          <div v-for="color in theme.colors" :key="color" :style="{ backgroundColor: color }"></div>
        </div>
        <div class="color-theme-name">{{ theme.name }}</div>
      </div>
    </div>
  </div>


<!-- Gradient Controls -->
<div :class="['gradient-controls', background.type === 'gradient' ? 'active' : '']">
    <h4>Gradient Type</h4>
    <div class="gradient-type-selector">
      <div 
        :class="['gradient-type-btn', background.gradient.type === 'linear' ? 'active' : '']" 
        @click="background.gradient.type = 'linear'"
      >Linear</div>
      <div 
        :class="['gradient-type-btn', background.gradient.type === 'radial' ? 'active' : '']" 
        @click="background.gradient.type = 'radial'"
      >Radial</div>
      <div 
        :class="['gradient-type-btn', background.gradient.type === 'conic' ? 'active' : '']" 
        @click="background.gradient.type = 'conic'"
      >Conic</div>
    </div>
    
    <div v-if="background.gradient.type === 'linear'">
      <h4>Angle (degrees)</h4>
      <div class="range-with-value">
        <input 
          type="range" 
          min="0" 
          max="360" 
          step="1" 
          v-model.number="background.gradient.angle"
        >
        <span>{{ background.gradient.angle }}°</span>
      </div>
    </div>
    
    <h4>Gradient Stops</h4>
    <div 
      v-for="(stop, index) in background.gradient.stops" 
      :key="index" 
      class="gradient-stop"
    >
      <div class="dual-color-input">
        <div class="dual-color-row">
          <input type="color" v-model="stop.color.light">
          <input type="text" v-model="stop.color.light">
        </div>
        <div class="dual-color-row" v-if="!colorLinked">
          <input type="color" v-model="stop.color.dark">
          <input type="text" v-model="stop.color.dark">
        </div>
      </div>
      
      <input 
        type="range" 
        min="0" 
        max="100" 
        step="1" 
        v-model.number="stop.position"
      >
      <span class="stop-position">{{ stop.position }}%</span>
      
      <button 
        class="btn small" 
        @click="background.gradient.stops.splice(index, 1)" 
        v-if="background.gradient.stops.length > 2"
      >
        <i class="fas fa-times"></i>
      </button>
    </div>
    
    <button 
      class="btn gradient-add-stop" 
      @click="addGradientStop" 
      v-if="background.gradient.stops.length < 5"
    >
      Add Color Stop
    </button>
    
    <h4>Color Themes</h4>
    <div class="color-themes-grid">
      <div 
        v-for="theme in colorThemes" 
        :key="theme.name" 
        class="color-theme" 
        @click="applyColorTheme(theme, 'gradient')"
      >
        <div class="color-theme-preview">
          <div v-for="color in theme.colors" :key="color" :style="{ backgroundColor: color }"></div>
        </div>
        <div class="color-theme-name">{{ theme.name }}</div>
      </div>
    </div>
  </div>

<!-- Pattern Controls -->
<div :class="['pattern-controls', background.type === 'pattern' ? 'active' : '']">
    <h4>Pattern Type</h4>
<div class="pattern-grid">
  <div v-if="patterns && patterns.length">
    <div 
      v-for="pattern in patterns" 
      :key="pattern.id" 
      :class="['pattern-swatch', background.pattern.id === pattern.id ? 'selected' : '']" 
      @click="selectPattern(pattern)"
      :style="getPatternPreviewStyle(pattern)"
    >
      <div class="pattern-name">{{ pattern.name }}</div>
    </div>
  </div>
  <div v-else>
    Loading patterns...
  </div>
</div>
    
    <div v-if="getSelectedPattern()">
      <h4>Pattern Scale</h4>
      <div class="range-with-value">
        <input 
          type="range" 
          min="10" 
          max="100" 
          step="1" 
          v-model.number="background.pattern.scale"
        >
        <span>{{ background.pattern.scale }}</span>
      </div>
      
      <div v-if="getSelectedPattern().supportsAngle">
        <h4>Pattern Angle (degrees)</h4>
        <div class="range-with-value">
          <input 
            type="range" 
            min="0" 
            max="360" 
            step="1" 
            v-model.number="background.pattern.angle"
          >
          <span>{{ background.pattern.angle }}°</span>
        </div>
      </div>
      
      <div class="pattern-colors">
        <h4>Pattern Colors</h4>
        <div 
          v-for="(color, index) in background.pattern.colors.slice(0, getSelectedPattern().colors)" 
          :key="index" 
          class="pattern-color-item"
        >
          <div class="dual-color-input">
            <div class="dual-color-row">
              <label>Color {{ index + 1 }}</label>
              <input type="color" v-model="color.light">
              <input type="text" v-model="color.light">
            </div>
            <div class="dual-color-row" v-if="!colorLinked">
              <label></label>
              <input type="color" v-model="color.dark">
              <input type="text" v-model="color.dark">
            </div>
          </div>
        </div>
      </div>
      
      <h4>Color Themes</h4>
      <div class="color-themes-grid">
        <div 
          v-for="theme in colorThemes" 
          :key="theme.name" 
          class="color-theme" 
          @click="applyColorTheme(theme, 'pattern')"
        >
          <div class="color-theme-preview">
            <div v-for="color in theme.colors" :key="color" :style="{ backgroundColor: color }"></div>
          </div>
          <div class="color-theme-name">{{ theme.name }}</div>
        </div>
      </div>
    </div>
  </div>

<!-- Texture Controls -->
<div :class="['texture-controls', background.type === 'texture' ? 'active' : '']">
    <h4>Select Texture</h4>
    <div class="texture-grid">
      <div 
        v-for="texture in textures" 
        :key="texture.id" 
        :class="['texture-swatch', background.texture.id === texture.id ? 'selected' : '']" 
        @click="selectTexture(texture)"
        :style="{ backgroundImage: `url(${texture.url})` }"
      >
        <div class="texture-name">{{ texture.name }}</div>
      </div>
    </div>
    
    <h4>Base Color</h4>
    <div class="dual-color-input">
      <div class="dual-color-row">
        <input type="color" v-model="background.texture.baseColor.light">
        <input type="text" v-model="background.texture.baseColor.light">
        <span class="link-both" :class="{ linked: colorLinked }" @click="toggleColorLink">
          <i class="fas" :class="colorLinked ? 'fa-link' : 'fa-unlink'"></i>
        </span>
      </div>
      <div class="dual-color-row" v-if="!colorLinked">
        <input type="color" v-model="background.texture.baseColor.dark">
        <input type="text" v-model="background.texture.baseColor.dark">
      </div>
    </div>
    
    <h4>Texture Scale</h4>
    <div class="range-with-value">
      <input 
        type="range" 
        min="50" 
        max="200" 
        step="10" 
        v-model.number="background.texture.scale"
      >
      <span>{{ background.texture.scale }}%</span>
    </div>
    
    <h4>Texture Opacity</h4>
    <div class="range-with-value">
      <input 
        type="range" 
        min="10" 
        max="100" 
        step="5" 
        v-model.number="background.texture.opacity"
      >
      <span>{{ background.texture.opacity }}%</span>
    </div>
  </div>
          
<!-- Image Controls -->
<div :class="['image-controls', background.type === 'image' ? 'active' : '']">
    <h4>Background Image</h4>
    <div class="image-input-container">
      <label for="image-upload" class="btn">Choose Image</label>
      <input type="file" id="image-upload" @change="handleImageUpload">
      <span class="file-name">{{ getImageFileName() }}</span>
    </div>
    
    <div class="image-preview-container" :style="getImagePreviewStyle()">
      <div class="image-overlay" v-if="background.overlay.enabled" 
          :style="{ backgroundColor: getCurrentColor(background.overlay.color), opacity: background.overlay.opacity/100 }"></div>
    </div>
    
    <div class="control-group">
      <label>Background Size</label>
      <select v-model="background.image.size">
        <option value="cover">Cover</option>
        <option value="contain">Contain</option>
        <option value="auto">Auto</option>
        <option value="custom">Custom Scale</option>
      </select>
      
      <div v-if="background.image.size === 'custom'" class="range-with-value">
        <label>Scale (%)</label>
        <input 
          type="range" 
          min="50" 
          max="200" 
          step="10" 
          v-model.number="background.image.scale"
        >
        <span>{{ background.image.scale }}%</span>
      </div>
    </div>
    
    <div class="control-group">
      <label>Background Position</label>
      <select v-model="background.image.position">
        <option value="center center">Center</option>
        <option value="top center">Top</option>
        <option value="bottom center">Bottom</option>
        <option value="left center">Left</option>
        <option value="right center">Right</option>
        <option value="top left">Top Left</option>
        <option value="top right">Top Right</option>
        <option value="bottom left">Bottom Left</option>
        <option value="bottom right">Bottom Right</option>
      </select>
    </div>
    
    <div class="control-group">
      <label>Background Repeat</label>
      <select v-model="background.image.repeat">
        <option value="no-repeat">No Repeat</option>
        <option value="repeat">Repeat</option>
        <option value="repeat-x">Repeat Horizontally</option>
        <option value="repeat-y">Repeat Vertically</option>
      </select>
    </div>
    
    <div class="control-group">
      <label>Background Attachment</label>
      <select v-model="background.image.attachment">
        <option value="scroll">Scroll</option>
        <option value="fixed">Fixed</option>
      </select>
    </div>
    
    <div class="control-group">
      <h4>Overlay</h4>
      <label class="checkbox-label">
        <input type="checkbox" v-model="background.overlay.enabled">
        Enable Color Overlay
      </label>
      
      <div v-if="background.overlay.enabled">
        <div class="dual-color-input">
          <div class="dual-color-row">
            <label>Overlay Color</label>
            <input type="color" v-model="background.overlay.color.light">
            <input type="text" v-model="background.overlay.color.light">
            <span class="link-both" :class="{ linked: colorLinked }" @click="toggleColorLink">
              <i class="fas" :class="colorLinked ? 'fa-link' : 'fa-unlink'"></i>
            </span>
          </div>
          <div class="dual-color-row" v-if="!colorLinked">
            <label></label>
            <input type="color" v-model="background.overlay.color.dark">
            <input type="text" v-model="background.overlay.color.dark">
          </div>
        </div>
        
        <label>Overlay Opacity</label>
        <div class="range-with-value">
          <input 
            type="range" 
            min="0" 
            max="100" 
            step="5" 
            v-model.number="background.overlay.opacity"
          >
          <span>{{ background.overlay.opacity }}%</span>
        </div>
      </div>
    </div>
  </div>


        </div>
        
        <div class="modal-footer">
          <button class="btn cancel" @click="$emit('close')">Cancel</button>
          <button class="btn save" @click="$emit('save', background)">Save Changes</button>
        </div>
      </div>
    </div>
  </script>

    <script type="text/x-template" id="font-selector-template">
    <div class="background-editor-modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3>Font Selector - {{ target === 'body' ? 'Body Text' : 'Headings' }}</h3>
          <button class="close-btn" @click="$emit('close')">×</button>
        </div>
        
        <div class="modal-body">
          <div class="font-selector-tabs">
            <div 
              :class="['font-selector-tab', tab === 'popular' ? 'active' : '']" 
              @click="$emit('set-tab', 'popular')"
            >Popular Fonts</div>
            <div 
              :class="['font-selector-tab', tab === 'all' ? 'active' : '']" 
              @click="$emit('set-tab', 'all')"
            >All Fonts</div>
            <div 
              :class="['font-selector-tab', tab === 'pairings' ? 'active' : '']" 
              @click="$emit('set-tab', 'pairings')"
            >Font Pairings</div>
          </div>
          
          <h4>Preview</h4>
          <div class="font-preview-container" :style="{ fontFamily: fontFamily }">
            <div :style="{ fontSize: '24px', marginBottom: '10px' }">
              The quick brown fox jumps over the lazy dog
            </div>
            <div>
              ABCDEFGHIJKLMNOPQRSTUVWXYZ<br>
              abcdefghijklmnopqrstuvwxyz<br>
              0123456789!@#$%^&*()
            </div>
          </div>
          
          <div :class="['font-selector-content', tab === 'popular' ? 'active' : '']">
            <div class="font-search">
              <i class="fas fa-search"></i>
              <input type="text" v-model="searchText" @input="onSearchInput" placeholder="Search fonts...">
            </div>
            
            <div class="font-grid">
              <div 
                v-for="font in filteredPopularFonts" 
                :key="font.family"
                :class="['font-grid-item', fontFamily === `'${font.family}', ${font.category}` ? 'selected' : '']"
                :style="{ fontFamily: `'${font.family}', ${font.category}` }"
                @click="onFontClick(font)"
              >
                <div>{{ font.family }}</div>
                <div style="font-size: 12px; color: #666;">{{ font.category }}</div>
              </div>
            </div>
          </div>
          
          <div :class="['font-selector-content', tab === 'all' ? 'active' : '']">
            <!-- All fonts content... -->
          </div>
          
          <div :class="['font-selector-content', tab === 'pairings' ? 'active' : '']">
            <div 
              v-for="pairing in fontPairings" 
              :key="pairing.name" 
              class="font-pairing" 
              @click="onPairingClick(pairing)"
            >
              <h4>{{ pairing.name }}</h4>
              <p>{{ pairing.description }}</p>
              <div class="font-pairing-preview">
                <div class="font-pairing-title" :style="{ fontFamily: pairing.heading }">Heading Font</div>
                <div class="font-pairing-body" :style="{ fontFamily: pairing.body }">Body text sample</div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="modal-footer">
          <button class="btn cancel" @click="$emit('close')">Cancel</button>
          <button class="btn save" @click="$emit('save')">Apply Font</button>
        </div>
      </div>
    </div>
  </script>

    <script type="text/x-template" id="color-picker-template">
    <div class="background-editor-modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3>Color Picker - {{ getColorPickerTitle() }}</h3>
          <button class="close-btn" @click="$emit('close')">×</button>
        </div>
        
        <div class="modal-body">
          <div class="dual-color-input">
            <div class="dual-color-row">
              <label>Light Mode</label>
              <input type="color" v-model="dualColor.light" @input="updateColor">
              <input type="text" v-model="dualColor.light" @input="updateColor">
              <span class="link-both" :class="{ linked: colorLinked }" @click="toggleColorLink">
                <i class="fas" :class="colorLinked ? 'fa-link' : 'fa-unlink'"></i>
              </span>
            </div>
            <div class="dual-color-row">
              <label>Dark Mode</label>
              <input type="color" v-model="dualColor.dark" :disabled="colorLinked" @input="updateColor">
              <input type="text" v-model="dualColor.dark" :disabled="colorLinked" @input="updateColor">
            </div>
          </div>
          
          <h4>Color Themes</h4>
          <div class="color-themes-grid">
            <div 
              v-for="theme in colorThemes" 
              :key="theme.name" 
              class="color-theme" 
              @click="applyColorTheme(theme)"
            >
              <div class="color-theme-preview">
                <div v-for="color in theme.colors" :key="color" :style="{ backgroundColor: color }"></div>
              </div>
              <div class="color-theme-name">{{ theme.name }}</div>
            </div>
          </div>
        </div>
        
        <div class="modal-footer">
          <button class="btn cancel" @click="$emit('close')">Cancel</button>
          <button class="btn save" @click="$emit('save', dualColor)">Apply Color</button>
        </div>
      </div>
    </div>
  </script>

    <script type="text/x-template" id="control-group-template">
    <div :class="['control-group', collapsed ? 'collapsed' : '']">
      <h3 @click="$emit('toggle')">
        <span class="toggle-icon"></span>{{ title }}
      </h3>
      <div class="control-content" v-show="!collapsed">
        <slot></slot>
      </div>
    </div>
  </script>

    <script type="text/x-template" id="slider-input-template">
    <div>
      <label v-if="label">{{ label }}</label>
      <div class="range-with-value">
        <input 
          type="range" 
          :min="min" 
          :max="max" 
          :step="step" 
          v-model.number="internalValue" 
          @input="updateValue"
        >
        <span>{{ internalValue }}{{ unit }}</span>
      </div>
    </div>
  </script>

    <script type="text/x-template" id="checkbox-input-template">
    <label class="checkbox-label">
      <input type="checkbox" v-model="internalValue" @change="updateValue">
      {{ label }}
    </label>
  </script>

    <script type="text/x-template" id="segmented-control-template">
    <div class="segmented-control">
      <template v-for="(option, index) in options">
        <input 
          type="radio" 
          :id="'segment-' + id + '-' + index" 
          :value="option.value" 
          v-model="internalValue" 
          @change="updateValue"
        >
        <label :for="'segment-' + id + '-' + index">{{ option.label }}</label>
      </template>
    </div>
  </script>

    <script type="text/x-template" id="dual-color-input-template">
    <div class="dual-color-input">
      <div class="dual-color-row">
        <label v-if="label">{{ label }}</label>
        <input 
          type="color" 
          v-model="dualColor.light" 
          @input="updateColor" 
          :class="{ active: colorMode === 'light' }"
        >
        <input 
          type="text" 
          v-model="dualColor.light" 
          @input="updateColor"
          :class="{ active: colorMode === 'light' }"
        >
        <span class="link-both" :class="{ linked: colorLinked }" @click="toggleColorLink" title="Link/unlink light and dark colors">
          <i class="fas" :class="colorLinked ? 'fa-link' : 'fa-unlink'"></i>
        </span>
      </div>
      <div class="dual-color-row" v-if="showDarkMode">
        <label v-if="label"></label>
        <input 
          type="color" 
          v-model="dualColor.dark" 
          :disabled="colorLinked" 
          @input="updateColor"
          :class="{ active: colorMode === 'dark' }"
        >
        <input 
          type="text" 
          v-model="dualColor.dark" 
          :disabled="colorLinked" 
          @input="updateColor"
          :class="{ active: colorMode === 'dark' }"
        >
      </div>
    </div>
  </script>

    <script>
        // Constants and utility functions
        const CONSTANTS = {
            // Patterns
            PATTERNS: [
                {
                    id: 'solid',
                    name: 'Solid',
                    colors: 1,
                    supportsScale: false,
                    supportsAngle: false,
                    css: (colors, scale, angle) => {
                        return `background-color: ${colors[0]};`;
                    }
                },
                {
                    id: 'linearGradient',
                    name: 'Linear Gradient',
                    colors: 2,
                    supportsScale: false,
                    supportsAngle: true,
                    css: (colors, scale, angle) => {
                        return `background: linear-gradient(${angle}deg, ${colors[0]}, ${colors[1]});`;
                    }
                },
                {
                    id: 'polkaDots',
                    name: 'Polka Dots',
                    colors: 2,
                    supportsScale: true,
                    supportsAngle: false,
                    css: (colors, scale) => {
                        return `
            background-color: ${colors[0]};
            background-image: radial-gradient(${colors[1]} ${scale / 6}px, transparent ${scale / 6}px);
            background-size: ${scale}px ${scale}px;
            background-position: 0 0, ${scale / 2}px ${scale / 2}px;
          `;
                    }
                },
                {
                    id: 'stripes',
                    name: 'Stripes',
                    colors: 2,
                    supportsScale: true,
                    supportsAngle: true,
                    css: (colors, scale, angle) => {
                        return `
            background: repeating-linear-gradient(
              ${angle}deg,
              ${colors[0]},
              ${colors[0]} ${scale / 2}px,
              ${colors[1]} ${scale / 2}px,
              ${colors[1]} ${scale}px
            );
          `;
                    }
                },
                {
                    id: 'zigzag',
                    name: 'Zigzag',
                    colors: 2,
                    supportsScale: true,
                    supportsAngle: false,
                    css: (colors, scale) => {
                        return `
            background-color: ${colors[0]};
            background-image: 
              linear-gradient(135deg, ${colors[1]} 25%, transparent 25%),
              linear-gradient(225deg, ${colors[1]} 25%, transparent 25%);
            background-size: ${scale}px ${scale}px;
            background-position: 0 0, ${scale / 2}px 0;
          `;
                    }
                }
            ],

            // Textures
            TEXTURES: [
                {
                    id: 'paper',
                    name: 'Paper',
                    url: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48ZmlsdGVyIGlkPSJhIj48ZmVUdXJidWxlbmNlIHR5cGU9ImZyYWN0YWxOb2lzZSIgYmFzZUZyZXF1ZW5jeT0iLjg1IiBudW1PY3RhdmVzPSI1IiBzdGl0Y2hUaWxlcz0ic3RpdGNoIi8+PGZlQ29sb3JNYXRyaXggdmFsdWVzPSIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAxIDAiLz48L2ZpbHRlcj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWx0ZXI9InVybCgjYSkiLz48L3N2Zz4='
                }
            ],

            // Color Themes
            COLOR_THEMES: [
                {
                    name: 'Blues',
                    colors: ['#0096FF', '#0074D9', '#004d99', '#001f3d'],
                    darks: ['#001f3d', '#004d99', '#0074D9', '#0096FF']
                },
                {
                    name: 'Greens',
                    colors: ['#2ECC40', '#01FF70', '#1a9930', '#0d4c18'],
                    darks: ['#0d4c18', '#1a9930', '#2ECC40', '#01FF70']
                },
                {
                    name: 'Reds',
                    colors: ['#FF4136', '#FF851B', '#991a1a', '#590b0b'],
                    darks: ['#590b0b', '#991a1a', '#FF4136', '#FF851B']
                },
                {
                    name: 'Purples',
                    colors: ['#B10DC9', '#9900ff', '#660099', '#330033'],
                    darks: ['#330033', '#660099', '#9900ff', '#B10DC9']
                },
                {
                    name: 'Grays',
                    colors: ['#AAAAAA', '#777777', '#444444', '#111111'],
                    darks: ['#111111', '#444444', '#777777', '#AAAAAA']
                },
                {
                    name: 'Earth Tones',
                    colors: ['#A97142', '#D2B48C', '#7d532f', '#3d2916'],
                    darks: ['#3d2916', '#7d532f', '#A97142', '#D2B48C']
                },
                {
                    name: 'Pastel',
                    colors: ['#FFD1DC', '#FFECB3', '#B3FFD9', '#B3D9FF'],
                    darks: ['#990033', '#996600', '#006633', '#003366']
                },
                {
                    name: 'Dark Mode',
                    colors: ['#121212', '#1F1F1F', '#2D2D2D', '#383838'],
                    darks: ['#fafafa', '#f5f5f5', '#eeeeee', '#e0e0e0']
                }
            ],

            // Font Pairings
            FONT_PAIRINGS: [
                {
                    name: 'Modern Sans',
                    description: 'Clean, modern sans-serif combination',
                    heading: "'Montserrat', sans-serif",
                    body: "'Open Sans', sans-serif"
                },
                {
                    name: 'Classic Serif',
                    description: 'Timeless serif combination with excellent readability',
                    heading: "'Playfair Display', serif",
                    body: "'Lora', serif"
                },
                {
                    name: 'Contemporary Mix',
                    description: 'Sans-serif headings with serif body for contrast',
                    heading: "'Raleway', sans-serif",
                    body: "'Merriweather', serif"
                },
                {
                    name: 'Professional',
                    description: 'Clean professional look for corporate sites',
                    heading: "'Roboto', sans-serif",
                    body: "'Source Sans Pro', sans-serif"
                },
                {
                    name: 'Elegant',
                    description: 'Elegant combination with excellent readability',
                    heading: "'Cormorant Garamond', serif",
                    body: "'EB Garamond', serif"
                },
                {
                    name: 'Creative',
                    description: 'Creative combination with personality',
                    heading: "'Abril Fatface', display",
                    body: "'Poppins', sans-serif"
                }
            ],

            // Google Fonts
            GOOGLE_FONTS: [
                { family: 'Roboto', category: 'sans-serif' },
                { family: 'Open Sans', category: 'sans-serif' },
                { family: 'Lato', category: 'sans-serif' },
                { family: 'Montserrat', category: 'sans-serif' },
                { family: 'Roboto Condensed', category: 'sans-serif' },
                { family: 'Source Sans Pro', category: 'sans-serif' },
                { family: 'Oswald', category: 'sans-serif' },
                { family: 'Raleway', category: 'sans-serif' },
                { family: 'Ubuntu', category: 'sans-serif' },
                { family: 'Merriweather', category: 'serif' },
                { family: 'PT Sans', category: 'sans-serif' },
                { family: 'Roboto Slab', category: 'serif' },
                { family: 'Playfair Display', category: 'serif' },
                { family: 'Lora', category: 'serif' },
                { family: 'Poppins', category: 'sans-serif' },
                { family: 'Noto Sans', category: 'sans-serif' },
                { family: 'Nunito', category: 'sans-serif' },
                { family: 'Quicksand', category: 'sans-serif' },
                { family: 'Work Sans', category: 'sans-serif' },
                { family: 'Fira Sans', category: 'sans-serif' }
                // ... additional fonts truncated for brevity
            ]
        };

        // Utility functions
        const ThemeUtils = {
            // Color utility functions
            // Color utility functions
            hexToRgb(hex) {
                // Remove # if present
                hex = hex.replace('#', '');

                // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
                if (hex.length === 3) {
                    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
                }

                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);

                return isNaN(r) || isNaN(g) || isNaN(b) ? '0,0,0' : `${r},${g},${b}`;
            },

            darkenColor(hex, percent) {
                // Strip the leading # if it exists
                hex = hex.replace(/^\s*#|\s*$/g, '');

                // Convert 3 char to 6 char
                if (hex.length == 3) {
                    hex = hex.replace(/(.)/g, '$1$1');
                }

                // Convert hex to rgb
                var rgb = parseInt(hex, 16);
                var r = (rgb >> 16) & 0xff;
                var g = (rgb >> 8) & 0xff;
                var b = (rgb >> 0) & 0xff;

                // Darken
                r = Math.max(0, Math.floor(r * (100 - percent) / 100));
                g = Math.max(0, Math.floor(g * (100 - percent) / 100));
                b = Math.max(0, Math.floor(b * (100 - percent) / 100));

                // Convert back to hex
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            },

            lightenColor(hex, percent) {
                // Strip the leading # if it exists
                hex = hex.replace(/^\s*#|\s*$/g, '');

                // Convert 3 char to 6 char
                if (hex.length == 3) {
                    hex = hex.replace(/(.)/g, '$1$1');
                }

                // Convert hex to rgb
                var rgb = parseInt(hex, 16);
                var r = (rgb >> 16) & 0xff;
                var g = (rgb >> 8) & 0xff;
                var b = (rgb >> 0) & 0xff;

                // Lighten
                r = Math.min(255, Math.floor(r * (100 + percent) / 100));
                g = Math.min(255, Math.floor(g * (100 + percent) / 100));
                b = Math.min(255, Math.floor(b * (100 + percent) / 100));

                // Convert back to hex
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            },

            // Makes a color dual-mode compatible
            makeColorDual(color) {
                // If it's already a dual color object, return it
                if (color && typeof color === 'object' && 'light' in color && 'dark' in color) {
                    return color;
                }

                // If it's a string (hex color), create a dual color object
                if (typeof color === 'string') {
                    return {
                        light: color,
                        dark: this.invertColor(color)
                    };
                }

                // Default fallback
                return {
                    light: '#000000',
                    dark: '#ffffff'
                };
            },

            // Simple color inversion for dark mode
            invertColor(hex) {
                // Remove # if present
                hex = hex.replace('#', '');

                // Convert to RGB
                let r = parseInt(hex.substring(0, 2), 16);
                let g = parseInt(hex.substring(2, 4), 16);
                let b = parseInt(hex.substring(4, 6), 16);

                // If it's dark, return a light color
                if (r + g + b < 128 * 3) {
                    return '#' + ThemeUtils.lightenColor(hex, 70).replace('#', '');
                }

                // If it's light, return a dark color
                return '#' + ThemeUtils.darkenColor(hex, 70).replace('#', '');
            },

            // Get current color value based on mode
            getCurrentColor(colorObj, mode) {
                if (!colorObj) return '#000000';

                if (typeof colorObj === 'string') {
                    // If it's a string, convert to dual format first
                    colorObj = this.makeColorDual(colorObj);
                }

                return mode === 'dark' ? colorObj.dark : colorObj.light;
            },

            // Deep clone an object
            deepClone(obj) {
                return JSON.parse(JSON.stringify(obj));
            },

            // Deep merge objects
            deepMerge(target, source) {
                for (const key in source) {
                    if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                        if (!target[key]) target[key] = {};
                        this.deepMerge(target[key], source[key]);
                    } else {
                        target[key] = source[key];
                    }
                }
                return target;
            },

            // Create a debounce function
            debounce(func, wait) {
                let timeout;
                return function () {
                    const context = this;
                    const args = arguments;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => {
                        func.apply(context, args);
                    }, wait);
                };
            }
        };

        // Basic UI Components
        Vue.component('slider-input', {
            template: '#slider-input-template',
            props: {
                value: { type: Number, required: true },
                min: { type: Number, default: 0 },
                max: { type: Number, default: 100 },
                step: { type: Number, default: 1 },
                label: String,
                unit: { type: String, default: '' }
            },
            data() {
                return {
                    internalValue: this.value
                };
            },
            watch: {
                value(newValue) {
                    this.internalValue = newValue;
                }
            },
            methods: {
                updateValue() {
                    this.$emit('input', this.internalValue);
                }
            }
        });

        Vue.component('checkbox-input', {
            template: '#checkbox-input-template',
            props: {
                value: { type: Boolean, required: true },
                label: { type: String, required: true }
            },
            data() {
                return {
                    internalValue: this.value
                };
            },
            watch: {
                value(newValue) {
                    this.internalValue = newValue;
                }
            },
            methods: {
                updateValue() {
                    this.$emit('input', this.internalValue);
                }
            }
        });

        Vue.component('segmented-control', {
            template: '#segmented-control-template',
            props: {
                value: { required: true },
                options: { type: Array, required: true }
            },
            data() {
                return {
                    internalValue: this.value,
                    id: 'seg-' + Math.floor(Math.random() * 10000)
                };
            },
            watch: {
                value(newValue) {
                    this.internalValue = newValue;
                }
            },
            methods: {
                updateValue() {
                    this.$emit('input', this.internalValue);
                }
            }
        });

        Vue.component('dual-color-input', {
            template: '#dual-color-input-template',
            props: {
                value: { required: true },
                label: String,
                colorMode: { type: String, default: 'light' }
            },
            data() {
                return {
                    dualColor: this.initDualColor(),
                    colorLinked: true,
                    showDarkMode: false
                };
            },
            watch: {
                value: {
                    handler(newValue) {
                        this.dualColor = this.initDualColor();
                    },
                    deep: true
                }
            },
            methods: {
                initDualColor() {
                    // Convert to dual color format if needed
                    if (typeof this.value === 'string') {
                        return {
                            light: this.value,
                            dark: ThemeUtils.invertColor(this.value)
                        };
                    } else if (this.value && typeof this.value === 'object') {
                        return {
                            light: this.value.light || '#000000',
                            dark: this.value.dark || '#ffffff'
                        };
                    }
                    return { light: '#000000', dark: '#ffffff' };
                },

                updateColor() {
                    // If colors are linked, update dark color based on light
                    if (this.colorLinked) {
                        this.dualColor.dark = ThemeUtils.invertColor(this.dualColor.light);
                    }
                    // Emit the updated dual color
                    this.$emit('input', this.dualColor);
                },

                toggleColorLink() {
                    this.colorLinked = !this.colorLinked;
                    this.showDarkMode = !this.colorLinked;
                    if (this.colorLinked) {
                        this.dualColor.dark = ThemeUtils.invertColor(this.dualColor.light);
                        this.updateColor();
                    }
                }
            }
        });

        Vue.component('control-group', {
            template: '#control-group-template',
            props: {
                title: { type: String, required: true },
                collapsed: { type: Boolean, default: false }
            }
        });

        // Complex Components
        Vue.component('responsive-preview-control', {
            template: '#responsive-preview-control-template',
            props: {
                responsivePreview: { type: Object, required: true }
            }
        });

        Vue.component('content-source-control', {
            template: '#content-source-control-template',
            props: {
                content: { type: Object, required: true },
                wikiState: { type: Object, required: true }
            },
            data() {
                return {
                    collapsed: false,
                    wikiSearch: ''
                };
            },
            methods: {
                toggleCollapsed() {
                    this.collapsed = !this.collapsed;
                },
                setContentSource(source) {
                    this.content.source = source;
                },
                onWikiSearchInput() {
                    // Debounced wiki search
                    this.$emit('search-wiki', this.wikiSearch);
                },
                onWikiResultClick(result) {
                    this.$emit('select-wiki', result);
                }
            }
        });

        Vue.component('design-controls', {
            template: '#design-controls-template',
            props: {
                theme: { type: Object, required: true },
                editorState: { type: Object, required: true },
                collapsedGroups: { type: Object, required: true }
            },
            methods: {
                onToggleGroup(group) {
                    this.$emit('toggle-group', group);
                },
                getCurrentColor(colorObj) {
                    return ThemeUtils.getCurrentColor(colorObj, this.editorState.colorMode);
                },
                getBackgroundPreviewStyle(target) {
                    // Get background style for the preview
                    const bgSettings = this.theme.backgrounds[target];
                    const mode = this.editorState.colorMode;

                    return CSSStyleGenerator.getBackgroundStyle(bgSettings, mode);
                }
            }
        });

        Vue.component('export-controls', {
            template: '#export-controls-template',
            props: {
                theme: { type: Object, required: true }
            }
        });

        Vue.component('theme-preview', {
            template: '#theme-preview-template',
            props: {
                theme: { type: Object, required: true },
                editorState: { type: Object, required: true },
                isLoading: { type: Boolean, default: false }
            },
            methods: {
                updatePreview(cssCode, htmlContent) {
                    const frame = this.$refs.previewFrame;
                    const doc = frame.contentDocument || frame.contentWindow.document;

                    doc.open();
                    doc.write(`
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            ${this.theme.loadedFonts.map(font => `<link href="${font}" rel="stylesheet">`).join('\n')}
            <style>${cssCode}</style>
          </head>
          <body>
            ${htmlContent}
          </body>
          </html>
        `);
                    doc.close();
                }
            }
        });

        Vue.component('editor-controls', {
            template: '#editor-controls-template',
            props: {
                theme: { type: Object, required: true },
                editorState: { type: Object, required: true },
                isLoading: { type: Boolean, default: false }
            },
            methods: {
                refreshPreview() {
                    this.$emit('update-preview');
                },
                toggleDarkMode() {
                    this.$emit('toggle-dark-mode');
                },
                onToggleGroup(group) {
                    this.$emit('toggle-group', group);
                },
                onGenerateNewLorem() {
                    this.$emit('generate-new-lorem');
                },
                onSearchWikipedia(query) {
                    this.$emit('search-wikipedia', query);
                },
                onSelectWikiArticle(article) {
                    this.$emit('select-wiki-article', article);
                },
                onFetchWikiArticleContent() {
                    this.$emit('fetch-wiki-article');
                },
                onOpenBackgroundEditor(target) {
                    this.$emit('open-background-editor', target);
                },
                onOpenFontSelector(target) {
                    this.$emit('open-font-selector', target);
                },
                onOpenColorPicker(target) {
                    this.$emit('open-color-picker', target);
                },
                onExportCSS() {
                    this.$emit('export-css');
                },
                onExportHTML() {
                    this.$emit('export-html');
                },
                onCopyCSS() {
                    this.$emit('copy-css');
                },
                onExportThemeJSON() {
                    this.$emit('export-theme-json');
                },
                onImportThemeJSON() {
                    this.$emit('import-theme-json');
                },
                onApplyPreset(preset) {
                    this.$emit('apply-preset', preset);
                }
            }
        });

        Vue.component('background-editor', {
            template: '#background-editor-template',
            props: {
                background: { type: Object, required: true },
                target: { type: String, required: true },
                colorMode: { type: String, default: 'light' }
            },
            data() {
                return {
                    colorLinked: true,
                    colorThemes: CONSTANTS.COLOR_THEMES,
                    patterns: CONSTANTS.PATTERNS,
                    textures: CONSTANTS.TEXTURES
                };
            },
            methods: {
                getBackgroundEditorTitle() {
                    if (this.target === 'body') {
                        return 'Body Background';
                    } else if (this.target === 'page') {
                        return 'Page Background';
                    } else {
                        return 'Hero Panel Background';
                    }
                },

                getTempBackgroundStyle() {
                    // Get style for the background preview
                    return CSSStyleGenerator.getBackgroundStyle(this.background, this.colorMode);
                },

                getCurrentColor(colorObj) {
                    return ThemeUtils.getCurrentColor(colorObj, this.colorMode);
                },

                applyColorTheme(theme, targetType) {
                    const themeColors = this.colorMode === 'dark' ? theme.darks : theme.colors;

                    if (targetType === 'color') {
                        // Apply color theme to solid color
                        this.background.color.light = themeColors[0];
                        if (this.colorLinked) {
                            this.background.color.dark = ThemeUtils.invertColor(themeColors[0]);
                        } else {
                            // Choose appropriate dark color from the theme
                            this.background.color.dark = theme.darks[0];
                        }
                    } else if (targetType === 'gradient') {
                        // Apply color theme to gradient stops
                        const { stops } = this.background.gradient;
                        const colors = themeColors.slice(0, stops.length);
                        const darkColors = theme.darks.slice(0, stops.length);

                        // Apply colors to existing stops
                        stops.forEach((stop, i) => {
                            if (i < colors.length) {
                                stop.color = {
                                    light: colors[i],
                                    dark: darkColors[i]
                                };
                            }
                        });
                    } else if (targetType === 'pattern') {
                        // Apply color theme to pattern colors
                        const pattern = this.getSelectedPattern();
                        if (pattern) {
                            const colorsNeeded = Math.min(pattern.colors, themeColors.length);

                            for (let i = 0; i < colorsNeeded; i++) {
                                this.background.pattern.colors[i] = {
                                    light: themeColors[i],
                                    dark: theme.darks[i]
                                };
                            }
                        }
                    }
                },

                toggleColorLink() {
                    this.colorLinked = !this.colorLinked;

                    if (this.colorLinked) {
                        // Update dark mode colors based on light mode
                        this.background.color.dark = ThemeUtils.invertColor(this.background.color.light);
                    }
                },

                getSelectedPattern() {
                    return CONSTANTS.PATTERNS.find(p => p.id === this.background.pattern.id);
                },

                // Add these methods inside the component's methods object
                addGradientStop() {
                    // Get the last stop position
                    const lastStop = this.background.gradient.stops[this.background.gradient.stops.length - 1];
                    const newPosition = Math.min(lastStop.position + 20, 100);

                    // Add a new stop with a color between the last two stops
                    this.background.gradient.stops.push({
                        color: {
                            light: this.background.gradient.stops[0].color.light,
                            dark: this.background.gradient.stops[0].color.dark
                        },
                        position: newPosition
                    });
                },

                getPatternPreviewStyle(pattern) {
                    // Safety check if pattern is undefined
                    if (!pattern || !pattern.css) {
                        return { backgroundColor: '#f5f5f5' };
                    }

                    // Generate a preview style for a pattern
                    try {
                        const colors = this.background.pattern.colors.slice(0, pattern.colors).map(
                            color => this.getCurrentColor(color, this.colorMode)
                        );

                        // Get CSS style for the pattern
                        const cssText = pattern.css(
                            colors,
                            20, // Small scale for preview
                            pattern.supportsAngle ? this.background.pattern.angle : 0
                        );

                        return cssText;
                    } catch (error) {
                        console.error('Error generating pattern preview:', error);
                        return { backgroundColor: '#f5f5f5' }; // Fallback
                    }
                },

                selectPattern(pattern) {
                    this.background.pattern.id = pattern.id;

                    // Make sure we have enough colors
                    while (this.background.pattern.colors.length < pattern.colors) {
                        this.background.pattern.colors.push({
                            light: '#ffffff',
                            dark: '#333333'
                        });
                    }
                },

                getSelectedPattern() {
                    return CONSTANTS.PATTERNS.find(p => p.id === this.background.pattern.id);
                },

                selectTexture(texture) {
                    this.background.texture.id = texture.id;
                },

                handleImageUpload(event) {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = e => {
                            this.background.image.url = e.target.result;
                        };
                        reader.readAsDataURL(file);
                    }
                },

                getImageFileName() {
                    if (!this.background.image.url) return 'No file chosen';

                    if (this.background.image.url.startsWith('data:')) {
                        return 'Uploaded image';
                    }

                    return this.background.image.url.split('/').pop();
                },

                getImagePreviewStyle() {
                    if (!this.background.image.url) {
                        return {
                            backgroundColor: '#f9f9f9',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center'
                        };
                    }

                    return {
                        backgroundImage: `url(${this.background.image.url})`,
                        backgroundSize: this.background.image.size === 'custom' ? `${this.background.image.scale}%` : this.background.image.size,
                        backgroundPosition: this.background.image.position,
                        backgroundRepeat: this.background.image.repeat
                    };
                },

            }
        });

        Vue.component('font-selector', {
            template: '#font-selector-template',
            props: {
                fontFamily: { type: String, required: true },
                target: { type: String, required: true },
                tab: { type: String, default: 'popular' },
                search: { type: String, default: '' }
            },
            data() {
                return {
                    searchText: this.search,
                    fontPairings: CONSTANTS.FONT_PAIRINGS,
                    googleFonts: CONSTANTS.GOOGLE_FONTS
                };
            },
            computed: {
                filteredPopularFonts() {
                    const popularFonts = this.googleFonts.slice(0, 20);
                    if (!this.searchText) return popularFonts;

                    const searchLower = this.searchText.toLowerCase();
                    return popularFonts.filter(font =>
                        font.family.toLowerCase().includes(searchLower)
                    );
                }
            },
            methods: {
                onSearchInput() {
                    this.$emit('set-search', this.searchText);
                },
                onFontClick(font) {
                    this.$emit('select-font', font);
                },
                onPairingClick(pairing) {
                    this.$emit('select-pairing', pairing);
                }
            }
        });

        Vue.component('color-picker', {
            template: '#color-picker-template',
            props: {
                color: { required: true },
                target: { type: String, required: true },
                mode: { type: String, default: 'light' }
            },
            data() {
                return {
                    dualColor: this.initDualColor(),
                    colorLinked: true,
                    colorThemes: CONSTANTS.COLOR_THEMES
                };
            },
            methods: {
                initDualColor() {
                    // Convert to dual color format if needed
                    if (typeof this.color === 'string') {
                        return {
                            light: this.color,
                            dark: ThemeUtils.invertColor(this.color)
                        };
                    } else if (this.color && typeof this.color === 'object') {
                        return {
                            light: this.color.light || '#000000',
                            dark: this.color.dark || '#ffffff'
                        };
                    }
                    return { light: '#000000', dark: '#ffffff' };
                },

                updateColor() {
                    // If colors are linked, update dark color based on light
                    if (this.colorLinked) {
                        this.dualColor.dark = ThemeUtils.invertColor(this.dualColor.light);
                    }

                    // Emit the updated dual color
                    this.$emit('set-color', this.dualColor);
                },

                toggleColorLink() {
                    this.colorLinked = !this.colorLinked;
                    if (this.colorLinked) {
                        this.dualColor.dark = ThemeUtils.invertColor(this.dualColor.light);
                        this.updateColor();
                    }
                },

                getColorPickerTitle() {
                    if (this.target === 'text') {
                        return 'Text Color';
                    } else if (this.target === 'title') {
                        return 'Title Color';
                    } else if (this.target === 'heading') {
                        return 'Heading Color';
                    } else if (this.target === 'page-border') {
                        return 'Page Border Color';
                    }
                    return 'Color';
                },

                applyColorTheme(theme) {
                    // Apply color from theme
                    const colors = this.mode === 'dark' ? theme.darks : theme.colors;
                    this.dualColor.light = colors[0];

                    if (this.colorLinked) {
                        this.dualColor.dark = ThemeUtils.invertColor(colors[0]);
                    } else {
                        this.dualColor.dark = theme.darks[0];
                    }

                    this.updateColor();
                }
            }
        });
        // CSS Style Generator for component previews
        const CSSStyleGenerator = {
            getBackgroundStyle(bgSettings, mode) {
                if (!bgSettings) {
                    return { backgroundColor: '#ffffff' }; // Default fallback
                }

                const { type } = bgSettings;

                if (type === 'color') {
                    const color = ThemeUtils.getCurrentColor(bgSettings.color || { light: '#ffffff', dark: '#121212' }, mode);
                    return { backgroundColor: color };
                } else if (type === 'gradient' && bgSettings.gradient) {
                    const { gradient } = bgSettings;
                    const stops = gradient.stops.map(stop => {
                        const stopColor = ThemeUtils.getCurrentColor(stop.color, mode);
                        return `${stopColor} ${stop.position}%`;
                    }).join(', ');

                    if (gradient.type === 'linear') {
                        return { background: `linear-gradient(${gradient.angle}deg, ${stops})` };
                    } else if (gradient.type === 'radial') {
                        return { background: `radial-gradient(circle, ${stops})` };
                    } else if (gradient.type === 'conic') {
                        return { background: `conic-gradient(from 0deg, ${stops})` };
                    }
                } else if (type === 'pattern' && bgSettings.pattern) {
                    const pattern = CONSTANTS.PATTERNS.find(p => p.id === bgSettings.pattern.id);
                    if (pattern) {
                        // Get colors for current mode
                        const patternColors = bgSettings.pattern.colors.map(color =>
                            ThemeUtils.getCurrentColor(color, mode)
                        );

                        // Convert pattern.css output to style object
                        const cssText = pattern.css(
                            patternColors,
                            bgSettings.pattern.scale,
                            bgSettings.pattern.angle
                        );

                        return cssText;
                    }
                } else if (type === 'texture' && bgSettings.texture) {
                    const texture = CONSTANTS.TEXTURES.find(t => t.id === bgSettings.texture.id);
                    if (texture) {
                        const baseColor = ThemeUtils.getCurrentColor(bgSettings.texture.baseColor, mode);

                        return {
                            backgroundColor: baseColor,
                            backgroundImage: `url(${texture.url})`,
                            backgroundSize: `${bgSettings.texture.scale}%`,
                            backgroundBlendMode: 'multiply',
                            opacity: bgSettings.texture.opacity / 100 + 0.5
                        };
                    }
                } else if (type === 'image' && bgSettings.image) {
                    const { image } = bgSettings;

                    // Check if image.url exists to prevent errors
                    if (image.url) {
                        return {
                            backgroundImage: `url(${image.url})`,
                            backgroundSize: image.size === 'custom' ? `${image.scale}%` : image.size,
                            backgroundPosition: image.position,
                            backgroundRepeat: image.repeat,
                            backgroundAttachment: image.attachment
                        };
                    }
                }

                // Default
                return { backgroundColor: '#ffffff' };
            }
        };
        // CSS Generation Functions
        const CSSGenerator = {
            // Generate complete CSS for the theme
            generateCSS(theme, mode = 'light') {
                return [
                    this.generateBackgroundCSS(theme, mode),
                    this.generatePageCSS(theme, mode),
                    this.generateTypographyCSS(theme, mode),
                    this.generateHeroCSS(theme, mode),
                    this.generateImageCSS(theme, mode),
                    this.generateSectionCSS(theme, mode),
                    this.generateBlockquoteCSS(theme, mode),
                    this.generateTableCSS(theme, mode),
                    this.generateListCSS(theme, mode),
                    this.generateImageLinkCSS(theme, mode),
                    this.generateAdvancedCSS(theme, mode),
                ].join('');
            },

            // Generate background CSS
            generateBackgroundCSS(theme, mode) {
                let css = '/* Body Background */\n';
                css += 'body {\n';
                css += this.getBackgroundTypeCSS(theme.backgrounds.body, 'body', mode);
                css += '  margin: 0;\n  padding: 0;\n  min-height: 100vh;\n}\n\n';
                return css;
            },

            // Generate CSS for a specific background type
            getBackgroundTypeCSS(bgSettings, target, mode) {
                const { type } = bgSettings;
                let css = '';

                if (type === 'color') {
                    const color = ThemeUtils.getCurrentColor(bgSettings.color, mode);
                    css += `  background-color: ${color};\n`;
                } else if (type === 'gradient') {
                    // Handle gradient background
                    const { gradient } = bgSettings;
                    const stops = gradient.stops.map(stop => {
                        // Convert stop colors to dual mode if needed
                        const stopColor = ThemeUtils.getCurrentColor(stop.color, mode);
                        return `${stopColor} ${stop.position}%`;
                    }).join(', ');

                    if (gradient.type === 'linear') {
                        css += `  background: linear-gradient(${gradient.angle}deg, ${stops});\n`;
                    } else if (gradient.type === 'radial') {
                        css += `  background: radial-gradient(circle, ${stops});\n`;
                    } else if (gradient.type === 'conic') {
                        css += `  background: conic-gradient(from 0deg, ${stops});\n`;
                    }
                } else if (type === 'pattern' && bgSettings.pattern.id) {
                    const pattern = CONSTANTS.PATTERNS.find(p => p.id === bgSettings.pattern.id);
                    if (pattern) {
                        // Get colors adjusted for current mode
                        const patternColors = bgSettings.pattern.colors.map(color =>
                            ThemeUtils.getCurrentColor(color, mode)
                        );

                        // Get pattern CSS and format it for clean output
                        const patternCSS = pattern.css(
                            patternColors,
                            bgSettings.pattern.scale,
                            bgSettings.pattern.angle
                        );
                        const cssProps = patternCSS.split(';').filter(prop => prop.trim()).map(prop => `  ${prop.trim()};`).join('\n');
                        css += cssProps + '\n';
                    }
                } else if (type === 'texture' && bgSettings.texture.id) {
                    const texture = CONSTANTS.TEXTURES.find(t => t.id === bgSettings.texture.id);
                    if (texture) {
                        const baseColor = ThemeUtils.getCurrentColor(bgSettings.texture.baseColor, mode);
                        const textureColor = ThemeUtils.getCurrentColor(bgSettings.texture.textureColor, mode);

                        css += `  background-color: ${baseColor};\n`;
                        css += `  background-image: url(${texture.url});\n`;
                        css += `  background-size: ${bgSettings.texture.scale}%;\n`;
                        css += `  background-blend-mode: multiply;\n`;

                        if (bgSettings.texture.opacity < 100) {
                            css += `  /* Apply texture opacity using pseudo-element in actual implementation */\n`;
                        }
                    }
                } else if (type === 'image' && bgSettings.image.url) {
                    const { image } = bgSettings;

                    // For data URLs, add a comment
                    if (image.url.startsWith('data:')) {
                        css += `  /* Base64 image data abbreviated for readability */\n`;
                        css += `  background-image: url(${image.url.substring(0, 100)}...);\n`;
                    } else {
                        css += `  background-image: url(${image.url});\n`;
                    }

                    css += `  background-size: ${image.size === 'custom' ? `${image.scale}%` : image.size};\n`;
                    css += `  background-position: ${image.position};\n`;
                    css += `  background-repeat: ${image.repeat};\n`;
                    css += `  background-attachment: ${image.attachment};\n`;

                    // Add overlay as a comment since it needs a pseudo-element
                    if (bgSettings.overlay.enabled) {
                        const overlayColor = ThemeUtils.getCurrentColor(bgSettings.overlay.color, mode);
                        css += `  /* Overlay would be implemented with a pseudo-element: \n`;
                        css += `     color: ${overlayColor}; opacity: ${bgSettings.overlay.opacity}; */\n`;
                    }
                }

                return css;
            },

            // Generate page container CSS
            generatePageCSS(theme, mode) {
                const { enabled, shadowSize, borderSize, paddingX, paddingY, maxWidth, borderRadius } = theme.page;
                const borderColor = ThemeUtils.getCurrentColor(theme.page.borderColor, mode);

                let css = '/* Page Container */\n';
                css += '.page-container {\n';

                css += `  max-width: ${maxWidth}px;\n  margin: 40px auto;\n`;

                if (enabled) {
                    css += this.getBackgroundTypeCSS(theme.backgrounds.page, 'page', mode);

                    if (borderRadius > 0) {
                        css += `  border-radius: ${borderRadius}px;\n`;
                    }

                    if (shadowSize > 0) {
                        css += `  box-shadow: 0 0 ${shadowSize}px rgba(0, 0, 0, 0.2);\n`;
                    }

                    if (borderSize > 0) {
                        css += `  border: ${borderSize}px solid ${borderColor};\n`;
                    }
                }

                css += '  overflow: hidden;\n}\n\n';
                css += `/* Content Area */\n.content {\n  padding: ${paddingY}px ${paddingX}px;\n}\n\n`;
                return css;
            },

            // Generate typography CSS
            generateTypographyCSS(theme, mode) {
                const { bodyFont, headingFont, lineHeight, titleSize, titleStyle, titleAlign,
                    titlePaddingX, titlePaddingY, titleSpaceBelow,
                    headingSize, headingStyle, headingSpaceAbove, headingSpaceBelow,
                    textSize, linkUnderline, linkHoverEffect } = theme.type;

                // Get colors for current mode     
                const titleColor = ThemeUtils.getCurrentColor(theme.type.titleColor, mode);
                const headingColor = ThemeUtils.getCurrentColor(theme.type.headingColor, mode);
                const textColor = ThemeUtils.getCurrentColor(theme.type.textColor, mode);
                const linkColor = ThemeUtils.getCurrentColor(theme.type.linkColor, mode);
                const linkHoverColor = ThemeUtils.getCurrentColor(theme.type.linkHoverColor, mode);

                let css = '/* Typography */\n';

                css += `body {\n  font-family: ${bodyFont};\n  color: ${textColor};\n  font-size: ${textSize}px;\n  line-height: ${lineHeight};\n}\n\n`;

                // Common styles for headings
                css += `h1, h2, h3, h4, h5, h6 {\n  font-family: ${headingFont};\n}\n\n`;

                // Title styles
                css += `/* Main Title */\n.post-title {\n  color: ${titleColor};\n  font-size: ${titleSize}px;\n  margin-bottom: ${titleSpaceBelow}px;\n  font-weight: bold;\n  padding: ${titlePaddingY}px ${titlePaddingX}px;\n  text-align: ${titleAlign};\n`;

                switch (titleStyle) {
                    case 'underline':
                        css += `  border-bottom: 2px solid ${titleColor};\n  padding-bottom: 8px;\n`;
                        break;
                    case 'highlight':
                        css += `  background: linear-gradient(to bottom, transparent 50%, rgba(${ThemeUtils.hexToRgb(titleColor)}, 0.2) 50%);\n  display: inline-block;\n  padding: ${titlePaddingY}px ${titlePaddingX + 5}px;\n`;
                        break;
                    case 'bordered':
                        css += `  border: 2px solid ${titleColor};\n  padding: ${titlePaddingY + 10}px ${titlePaddingX + 10}px;\n`;
                        break;
                    case 'shadow':
                        css += `  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);\n`;
                        break;
                    case 'gradient':
                        css += `  background: linear-gradient(135deg, ${titleColor}, ${ThemeUtils.lightenColor(titleColor, 20)});\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  background-clip: text;\n`;
                        break;
                }

                css += '}\n\n';

                // Generate the rest of the CSS for headings, paragraphs, etc...
                // (This part is very similar to the previous code)

                return css;
            },


            // Generate Hero CSS
            generateHeroCSS(theme, mode) {
                if (!theme.hero || !theme.hero.enabled) return '';

                const { paddingX, paddingY, borderRadius, titleEffect } = theme.hero;

                let css = '/* Hero Panel */\n';
                css += '.hero-panel {\n';
                css += this.getBackgroundTypeCSS(theme.backgrounds.hero, 'hero', mode);
                css += `  padding: ${paddingY}px ${paddingX}px;\n`;

                if (borderRadius > 0) {
                    css += `  border-radius: ${borderRadius}px;\n`;
                }

                css += '  margin-bottom: 30px;\n';
                css += '}\n\n';

                // Add title text effect
                if (titleEffect !== 'none' && theme.hero.enabled) {
                    css += '.hero-panel .post-title {\n';

                    if (titleEffect === 'shadow') {
                        css += '  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);\n';
                    } else if (titleEffect === 'glow') {
                        css += '  text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);\n';
                    } else if (titleEffect === 'outline') {
                        css += '  -webkit-text-stroke: 1px rgba(0, 0, 0, 0.3);\n';
                    } else if (titleEffect === 'contrast') {
                        css += '  background-color: rgba(0, 0, 0, 0.6);\n';
                        css += '  color: white;\n';
                        css += '  padding: 10px 20px;\n';
                        css += '  display: inline-block;\n';
                    }

                    css += '}\n\n';
                }

                return css;
            },

            // Generate Image CSS
            generateImageCSS(theme, mode) {
                if (!theme.images) return '';

                const {
                    maxWidth, defaultAlign, borderSize, borderStyle, borderRadius,
                    shadowEnabled, shadowSize, shadowBlur, shadowOpacity,
                    marginTop, marginBottom, padding,
                    captionEnabled, captionPosition, captionFont, captionSize,
                    captionStyle, captionAlign, captionBgEnabled, captionBgOpacity,
                    brightness, contrast, saturation, hoverEffect
                } = theme.images;

                const borderColor = ThemeUtils.getCurrentColor(theme.images.borderColor, mode);
                const captionColor = ThemeUtils.getCurrentColor(theme.images.captionColor, mode);
                const captionBgColor = captionBgEnabled ?
                    ThemeUtils.getCurrentColor(theme.images.captionBgColor, mode) : 'transparent';

                let css = '/* Images */\n';

                // Container styles
                css += '.image-container {\n';
                css += `  margin: ${marginTop}px 0 ${marginBottom}px 0;\n`;
                css += `  max-width: ${maxWidth}%;\n`;

                if (defaultAlign === 'center') {
                    css += '  margin-left: auto;\n';
                    css += '  margin-right: auto;\n';
                }

                css += '}\n\n';

                // Image alignment variations
                css += '.image-left {\n';
                css += '  float: left;\n';
                css += '  margin-right: 20px;\n';
                css += '  max-width: 50%;\n';
                css += '}\n\n';

                css += '.image-right {\n';
                css += '  float: right;\n';
                css += '  margin-left: 20px;\n';
                css += '  max-width: 50%;\n';
                css += '}\n\n';

                css += '.image-full {\n';
                css += '  display: block;\n';
                css += '  width: 100%;\n';
                css += '  clear: both;\n';
                css += '}\n\n';

                // Image styles
                css += '.image-container img {\n';
                css += '  display: block;\n';
                css += '  width: 100%;\n';
                css += '  height: auto;\n';

                // Add image filters
                if (brightness !== 100 || contrast !== 100 || saturation !== 100) {
                    css += `  filter: brightness(${brightness / 100}) contrast(${contrast / 100}) saturate(${saturation / 100});\n`;
                }

                // Add border if size > 0
                if (borderSize > 0) {
                    css += `  border: ${borderSize}px ${borderStyle} ${borderColor};\n`;
                }

                // Add border radius
                if (borderRadius > 0) {
                    css += `  border-radius: ${borderRadius}px;\n`;
                }

                // Add padding
                if (padding > 0) {
                    css += `  padding: ${padding}px;\n`;
                }

                // Add shadow
                if (shadowEnabled && shadowSize > 0) {
                    const shadowOpacityValue = shadowOpacity / 100;
                    css += `  box-shadow: 0 0 ${shadowBlur}px rgba(0, 0, 0, ${shadowOpacityValue});\n`;
                }

                // Add transition for hover effects
                if (hoverEffect !== 'none') {
                    css += '  transition: all 0.3s ease;\n';
                }

                css += '}\n\n';

                // Hover effects
                if (hoverEffect !== 'none') {
                    css += '.image-container:hover img {\n';

                    switch (hoverEffect) {
                        case 'zoom':
                            css += '  transform: scale(1.05);\n';
                            break;
                        case 'brighten':
                            css += '  filter: brightness(1.2);\n';
                            break;
                        case 'saturate':
                            css += '  filter: saturate(1.5);\n';
                            break;
                        case 'blur':
                            css += '  filter: blur(2px);\n';
                            break;
                        case 'shadow':
                            css += '  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);\n';
                            break;
                    }

                    css += '}\n\n';
                }

                // Caption styles
                if (captionEnabled) {
                    css += '.image-caption {\n';

                    // Font styling
                    css += `  font-size: ${captionSize}px;\n`;
                    css += `  color: ${captionColor};\n`;
                    css += `  text-align: ${captionAlign};\n`;

                    // Caption font family
                    if (captionFont === 'headings') {
                        css += `  font-family: ${theme.type.headingFont};\n`;
                    } else if (captionFont !== 'inherit') {
                        css += `  font-family: ${captionFont};\n`;
                    }

                    // Font style
                    if (captionStyle === 'italic') {
                        css += '  font-style: italic;\n';
                    } else if (captionStyle === 'bold') {
                        css += '  font-weight: bold;\n';
                    } else if (captionStyle === 'bold-italic') {
                        css += '  font-weight: bold;\n';
                        css += '  font-style: italic;\n';
                    }

                    // Caption positioning
                    if (captionPosition === 'overlay') {
                        css += '  position: absolute;\n';
                        css += '  bottom: 0;\n';
                        css += '  left: 0;\n';
                        css += '  right: 0;\n';
                        css += '  padding: 10px;\n';
                    } else if (captionPosition === 'inside-border') {
                        css += '  padding: 8px;\n';
                        css += `  border-top: 1px ${borderStyle} ${borderColor};\n`;
                    } else {
                        // Below image
                        css += '  margin-top: 8px;\n';
                    }

                    // Caption background
                    if (captionBgEnabled) {
                        const bgOpacity = captionBgOpacity / 100;
                        const rgbValues = ThemeUtils.hexToRgb(captionBgColor.replace('#', ''));
                        css += `  background-color: rgba(${rgbValues}, ${bgOpacity});\n`;
                    }

                    css += '}\n\n';

                    // For overlay captions, we need relative positioning on the container
                    if (captionPosition === 'overlay') {
                        css += '.image-container {\n';
                        css += '  position: relative;\n';
                        css += '  overflow: hidden;\n';
                        css += '}\n\n';
                    }
                }

                return css;
            },

            // Generate Section CSS
            generateSectionCSS(theme, mode) {
                const {
                    dividerType, dividerWidth, dividerThickness,
                    spaceAbove, spaceBelow
                } = theme.sections;

                const dividerColor = ThemeUtils.getCurrentColor(theme.sections.dividerColor, mode);

                let css = '/* Section Dividers */\n';
                css += 'hr {\n';
                css += `  margin: ${spaceAbove}px auto ${spaceBelow}px auto;\n`;

                if (dividerType === 'line') {
                    css += '  border: none;\n';
                    css += `  border-top: ${dividerThickness}px solid ${dividerColor};\n`;
                    css += `  width: ${dividerWidth}%;\n`;
                } else if (dividerType === 'dashed') {
                    css += '  border: none;\n';
                    css += `  border-top: ${dividerThickness}px dashed ${dividerColor};\n`;
                    css += `  width: ${dividerWidth}%;\n`;
                } else if (dividerType === 'dotted') {
                    css += '  border: none;\n';
                    css += `  border-top: ${dividerThickness}px dotted ${dividerColor};\n`;
                    css += `  width: ${dividerWidth}%;\n`;
                } else if (dividerType === 'double') {
                    css += '  border: none;\n';
                    css += `  border-top: ${Math.max(1, dividerThickness - 1)}px solid ${dividerColor};\n`;
                    css += `  border-bottom: 1px solid ${dividerColor};\n`;
                    css += `  height: ${dividerThickness}px;\n`;
                    css += `  width: ${dividerWidth}%;\n`;
                }

                css += '}\n\n';

                return css;
            },

            // Generate Blockquote CSS
            generateBlockquoteCSS(theme, mode) {
                const {
                    style, borderSize, borderPosition, paddingX, paddingY,
                    fontStyle, spaceAbove, spaceBelow
                } = theme.blockquote;

                const borderColor = ThemeUtils.getCurrentColor(theme.blockquote.borderColor, mode);
                const backgroundColor = ThemeUtils.getCurrentColor(theme.blockquote.backgroundColor, mode);
                const textColor = ThemeUtils.getCurrentColor(theme.blockquote.textColor, mode);

                let css = '/* Blockquotes */\n';
                css += 'blockquote {\n';
                css += `  margin: ${spaceAbove}px 0 ${spaceBelow}px 0;\n`;
                css += `  padding: ${paddingY}px ${paddingX}px;\n`;
                css += `  color: ${textColor};\n`;

                if (fontStyle === 'italic') {
                    css += '  font-style: italic;\n';
                }

                if (style === 'border') {
                    css += `  border-${borderPosition}: ${borderSize}px solid ${borderColor};\n`;

                    if (borderPosition === 'left' || borderPosition === 'right') {
                        css += `  padding-${borderPosition}: ${paddingX}px;\n`;
                    }
                } else if (style === 'background') {
                    css += `  background-color: ${backgroundColor};\n`;

                    if (borderSize > 0) {
                        css += `  border: ${borderSize}px solid ${borderColor};\n`;
                    }
                } else if (style === 'quotation') {
                    css += '  position: relative;\n';
                    css += `  background-color: ${backgroundColor};\n`;
                    css += '  padding-left: 40px;\n';
                    css += '}\n\n';

                    css += 'blockquote:before {\n';
                    css += '  content: \'"\';\n';
                    css += '  position: absolute;\n';
                    css += '  left: 10px;\n';
                    css += '  top: 0;\n';
                    css += '  font-size: 3em;\n';
                    css += '  line-height: 1;\n';
                    css += `  color: ${borderColor};\n`;
                    css += '  font-family: Georgia, serif;\n';
                }

                css += '}\n\n';

                return css;
            },

            // Generate Table CSS
            generateTableCSS(theme, mode) {
                const {
                    style, borderType, borderSize, cellPaddingX, cellPaddingY,
                    spaceAbove, spaceBelow
                } = theme.table;

                const borderColor = ThemeUtils.getCurrentColor(theme.table.borderColor, mode);
                const headerBackground = ThemeUtils.getCurrentColor(theme.table.headerBackground, mode);
                const headerTextColor = ThemeUtils.getCurrentColor(theme.table.headerTextColor, mode);
                const rowBackground = ThemeUtils.getCurrentColor(theme.table.rowBackground, mode);
                const altRowBackground = ThemeUtils.getCurrentColor(theme.table.altRowBackground, mode);

                let css = '/* Tables */\n';
                css += 'table {\n';
                css += '  width: 100%;\n';
                css += '  border-collapse: collapse;\n';
                css += `  margin: ${spaceAbove}px 0 ${spaceBelow}px 0;\n`;
                css += '}\n\n';

                // Table headers
                css += 'table th {\n';
                css += `  background-color: ${headerBackground};\n`;
                css += `  color: ${headerTextColor};\n`;
                css += '  font-weight: bold;\n';
                css += `  padding: ${cellPaddingY}px ${cellPaddingX}px;\n`;
                css += '  text-align: left;\n';

                // Add borders based on style
                if (borderType === 'all' || borderType === 'horizontal') {
                    css += `  border-bottom: ${borderSize}px solid ${borderColor};\n`;
                }

                if (borderType === 'all' || borderType === 'vertical') {
                    css += `  border-right: ${borderSize}px solid ${borderColor};\n`;
                }

                if (borderType === 'all' || borderType === 'outer') {
                    css += `  border-top: ${borderSize}px solid ${borderColor};\n`;
                }

                css += '}\n\n';

                // Table cells
                css += 'table td {\n';
                css += `  padding: ${cellPaddingY}px ${cellPaddingX}px;\n`;

                // Add borders based on style
                if (borderType === 'all' || borderType === 'horizontal') {
                    css += `  border-bottom: ${borderSize}px solid ${borderColor};\n`;
                }

                if (borderType === 'all' || borderType === 'vertical') {
                    css += `  border-right: ${borderSize}px solid ${borderColor};\n`;
                }

                css += '}\n\n';

                // Alternate row backgrounds
                if (style === 'striped') {
                    css += 'table tr:nth-child(odd) {\n';
                    css += `  background-color: ${rowBackground};\n`;
                    css += '}\n\n';

                    css += 'table tr:nth-child(even) {\n';
                    css += `  background-color: ${altRowBackground};\n`;
                    css += '}\n\n';
                } else {
                    css += 'table tr {\n';
                    css += `  background-color: ${rowBackground};\n`;
                    css += '}\n\n';
                }

                // Outer border for the table if needed
                if (borderType === 'all' || borderType === 'outer') {
                    css += 'table {\n';
                    css += `  border: ${borderSize}px solid ${borderColor};\n`;
                    css += '}\n\n';
                }

                return css;
            },

            // Generate List CSS
            generateListCSS(theme, mode) {
                const { style, markerPosition, itemSpacing, nestedIndent } = theme.list;
                const bulletColor = ThemeUtils.getCurrentColor(theme.list.bulletColor, mode);

                let css = '/* Lists */\n';

                // Base list styles
                css += 'ul, ol {\n';
                css += `  padding-left: ${markerPosition === 'outside' ? '2em' : '1.5em'};\n`;
                css += '  margin: 1em 0;\n';
                css += '}\n\n';

                // List items
                css += 'li {\n';
                css += `  margin-bottom: ${itemSpacing}px;\n`;
                css += '}\n\n';

                // Nested lists
                css += 'li > ul, li > ol {\n';
                css += `  margin-top: ${itemSpacing}px;\n`;
                css += `  margin-left: ${nestedIndent}px;\n`;
                css += '}\n\n';

                // Custom bullets
                if (style === 'custom') {
                    css += 'ul {\n';
                    css += '  list-style: none;\n';
                    css += '}\n\n';

                    css += 'ul li:before {\n';
                    css += '  content: "•";\n';
                    css += `  color: ${bulletColor};\n`;
                    css += '  display: inline-block;\n';
                    css += '  width: 1em;\n';
                    css += '  margin-left: -1em;\n';
                    css += '}\n\n';
                }

                return css;
            },

            // Generate Image Links CSS
            generateImageLinkCSS(theme, mode) {
                if (!theme.imageLinks) return '';

                // Generate CSS for different layout types
                let css = '/* Image Links */\n';

                // Add container styles
                css += this.generateImageLinkContainerCSS(theme, mode);

                // Add item styles
                css += this.generateImageLinkItemsCSS(theme, mode);

                // Add hover effects
                css += this.generateImageLinkHoverEffectsCSS(theme, mode);

                // Add responsive adjustments
                css += this.generateImageLinkResponsiveCSS(theme, mode);

                return css;
            },

            // Container styles based on layout type
            generateImageLinkContainerCSS(theme, mode) {
                const { layout, displayStyle, itemsPerRow, spacing, gap } = theme.imageLinks;
                const backgroundColor = ThemeUtils.getCurrentColor(theme.imageLinks.backgroundColor, mode);

                let css = '.image-link-block {\n';

                // Apply layout-specific styles
                if (layout === 'grid') {
                    if (displayStyle === 'masonry') {
                        css += '  display: flex;\n';
                        css += '  flex-wrap: wrap;\n';
                        css += `  margin: -${gap / 2}px;\n`;
                    } else {
                        // Standard grid
                        css += '  display: grid;\n';
                        css += `  grid-template-columns: repeat(${itemsPerRow}, 1fr);\n`;
                        css += `  gap: ${gap}px;\n`;
                    }
                } else if (layout === 'carousel') {
                    // Carousel layout is handled separately
                    css += this.generateCarouselContainerCSS(theme, mode);
                } else {
                    // List layout
                    css += '  display: flex;\n';
                    css += '  flex-direction: column;\n';
                    css += `  gap: ${spacing}px;\n`;
                }

                // Apply background color
                if (backgroundColor && backgroundColor !== 'transparent') {
                    css += `  background-color: ${backgroundColor};\n`;
                }

                css += '}\n\n';
                return css;
            },

            // Carousel-specific container styles
            generateCarouselContainerCSS(theme, mode) {
                const { spacing, itemsPerRow } = theme.imageLinks;
                let css = '';

                // Basic carousel container
                css += '/* CSS-only Carousel */\n';
                css += '  display: flex;\n';
                css += '  flex-wrap: nowrap;\n';
                css += '  overflow-x: auto;\n';
                css += '  scroll-behavior: smooth;\n';
                css += '  -webkit-overflow-scrolling: touch;\n';
                css += '  scroll-snap-type: x mandatory;\n';
                css += `  gap: ${spacing}px;\n`;
                css += '  scrollbar-width: thin;\n';
                css += '  scrollbar-color: rgba(0,0,0,0.3) transparent;\n';
                css += '  padding-bottom: 10px;\n';

                // Scrollbar styling
                css += '}\n\n';
                css += '.image-link-block.carousel::-webkit-scrollbar {\n';
                css += '  height: 6px;\n';
                css += '}\n\n';

                css += '.image-link-block.carousel::-webkit-scrollbar-track {\n';
                css += '  background: transparent;\n';
                css += '}\n\n';

                css += '.image-link-block.carousel::-webkit-scrollbar-thumb {\n';
                css += '  background-color: rgba(0,0,0,0.3);\n';
                css += '  border-radius: 6px;\n';
                css += '}\n\n';

                // Carousel items
                css += '.image-link-block.carousel .image-link {\n';
                css += `  flex: 0 0 calc((100% / ${itemsPerRow}) - ${spacing * (itemsPerRow - 1) / itemsPerRow}px);\n`;
                css += '  scroll-snap-align: start;\n';
                css += '}\n\n';

                // Add carousel dots if enabled
                if (theme.imageLinks.carousel?.showDots) {
                    css += this.generateCarouselDotsCSS();
                }

                // Add auto-scroll animation if enabled
                if (theme.imageLinks.carousel?.autoScroll) {
                    css += this.generateCarouselAutoScrollCSS(theme);
                }

                // Add navigation arrows if enabled
                if (theme.imageLinks.carousel?.showArrows) {
                    css += this.generateCarouselArrowsCSS();
                }

                return css;
            },

            // Carousel dots
            generateCarouselDotsCSS() {
                let css = '.carousel-dots {\n';
                css += '  display: flex;\n';
                css += '  justify-content: center;\n';
                css += '  gap: 8px;\n';
                css += '  margin-top: 10px;\n';
                css += '}\n\n';

                css += '.carousel-dot {\n';
                css += '  width: 10px;\n';
                css += '  height: 10px;\n';
                css += '  border-radius: 50%;\n';
                css += '  background-color: rgba(0, 0, 0, 0.2);\n';
                css += '  cursor: pointer;\n';
                css += '  transition: all 0.3s ease;\n';
                css += '}\n\n';

                css += '.carousel-dot:hover {\n';
                css += '  background-color: rgba(0, 0, 0, 0.5);\n';
                css += '}\n\n';

                css += '.carousel-dot.active {\n';
                css += '  background-color: rgba(0, 0, 0, 0.6);\n';
                css += '}\n\n';

                css += '.carousel-dots a {\n';
                css += '  display: block;\n';
                css += '  width: 100%;\n';
                css += '  height: 100%;\n';
                css += '}\n\n';

                return css;
            },

            // Carousel auto-scroll animation
            generateCarouselAutoScrollCSS(theme) {
                const scrollSpeed = theme.imageLinks.carousel.scrollSpeed || 5;
                const itemCount = 5; // Number of sample items
                const { itemsPerRow } = theme.imageLinks;

                let css = '@keyframes carouselScroll {\n';

                // Create keyframes for each item position
                for (let i = 0; i < itemCount; i++) {
                    const percentStart = (i * 100) / itemCount;
                    const percentEnd = ((i + 1) * 100) / itemCount;
                    const percentHold = percentStart + (percentEnd - percentStart) * 0.8;

                    css += `  ${percentStart}% { scroll-left: ${i * 100 / itemsPerRow}%; }\n`;
                    css += `  ${percentHold}% { scroll-left: ${i * 100 / itemsPerRow}%; }\n`;
                }

                css += '  100% { scroll-left: 0%; }\n';
                css += '}\n\n';

                css += '.image-link-block.carousel.auto-scroll {\n';
                css += `  animation: carouselScroll ${itemCount * scrollSpeed}s infinite;\n`;
                css += '}\n\n';

                css += '.image-link-block.carousel.auto-scroll:hover {\n';
                css += '  animation-play-state: paused;\n';
                css += '}\n\n';

                return css;
            },

            // Carousel navigation arrows
            generateCarouselArrowsCSS() {
                let css = '.carousel-container {\n';
                css += '  position: relative;\n';
                css += '}\n\n';

                css += '.carousel-arrow {\n';
                css += '  position: absolute;\n';
                css += '  top: 50%;\n';
                css += '  transform: translateY(-50%);\n';
                css += '  width: 40px;\n';
                css += '  height: 40px;\n';
                css += '  background-color: rgba(0,0,0,0.3);\n';
                css += '  color: white;\n';
                css += '  border-radius: 50%;\n';
                css += '  display: flex;\n';
                css += '  align-items: center;\n';
                css += '  justify-content: center;\n';
                css += '  font-size: 18px;\n';
                css += '  cursor: pointer;\n';
                css += '  opacity: 0.7;\n';
                css += '  transition: opacity 0.3s ease;\n';
                css += '  z-index: 10;\n';
                css += '  text-decoration: none;\n';
                css += '}\n\n';

                css += '.carousel-arrow:hover {\n';
                css += '  opacity: 1;\n';
                css += '}\n\n';

                css += '.carousel-arrow-left {\n';
                css += '  left: 10px;\n';
                css += '}\n\n';

                css += '.carousel-arrow-right {\n';
                css += '  right: 10px;\n';
                css += '}\n\n';

                return css;
            },

            // Item styles for image links
            generateImageLinkItemsCSS(theme, mode) {
                const {
                    layout, displayStyle, gap, imagePosition, spacing, borderSize,
                    borderRadius, borderStyle, shadowStyle, shadowSize, shadowBlur,
                    shadowOpacity, aspectRatio, imageFit, imageOpacity, captionPosition,
                    captionSize, captionTextStyle, captionAlignment, captionPadding,
                    transitionSpeed
                } = theme.imageLinks;

                // Get theme colors
                const borderColor = ThemeUtils.getCurrentColor(theme.imageLinks.borderColor, mode);
                const captionColor = ThemeUtils.getCurrentColor(theme.imageLinks.captionColor, mode);
                const captionBgColor = ThemeUtils.getCurrentColor(theme.imageLinks.captionBackground, mode);
                const backgroundColor = ThemeUtils.getCurrentColor(theme.imageLinks.backgroundColor, mode);
                const shadowColor = ThemeUtils.getCurrentColor(theme.imageLinks.shadowColor, mode);

                // List specific styles
                const listImageWidth = theme.imageLinks.list?.imageWidth || 100;
                const listImageHeight = theme.imageLinks.list?.imageHeight || 70;
                const showDivider = theme.imageLinks.list?.showDivider || false;
                const dividerColor = theme.imageLinks.list?.dividerColor
                    ? ThemeUtils.getCurrentColor(theme.imageLinks.list.dividerColor, mode)
                    : '#eeeeee';

                let css = '';

                // Individual link items
                css += '.image-link {\n';
                css += '  text-decoration: none;\n';
                css += '  color: inherit;\n';
                css += `  transition: all ${transitionSpeed}s ease;\n`;
                css += `  background-color: ${backgroundColor};\n`;

                // Layout specific styles
                if (layout === 'grid' && displayStyle === 'masonry') {
                    css += `  width: calc(${100 / theme.imageLinks.itemsPerRow}% - ${gap}px);\n`;
                    css += `  margin: ${gap / 2}px;\n`;
                } else if (layout === 'list') {
                    css += '  display: flex;\n';
                    css += `  flex-direction: ${imagePosition === 'left' ? 'row' : 'row-reverse'};\n`;
                    css += '  align-items: center;\n';
                    css += `  gap: ${spacing}px;\n`;

                    if (showDivider) {
                        css += `  border-bottom: 1px solid ${dividerColor};\n`;
                        css += '  padding-bottom: 10px;\n';
                    }
                }

                // Border styles
                if (borderSize > 0) {
                    css += `  border: ${borderSize}px ${borderStyle} ${borderColor};\n`;
                }

                if (borderRadius > 0) {
                    css += `  border-radius: ${borderRadius}px;\n`;
                }

                // Box shadow
                if (shadowStyle !== 'none') {
                    let boxShadow = '';
                    if (shadowStyle === 'light') {
                        boxShadow = `0 2px 5px rgba(0,0,0,0.1)`;
                    } else if (shadowStyle === 'medium') {
                        boxShadow = `0 4px 10px rgba(0,0,0,0.15)`;
                    } else if (shadowStyle === 'dark') {
                        boxShadow = `0 6px 15px rgba(0,0,0,0.2)`;
                    } else if (shadowStyle === 'custom') {
                        const rgba = `rgba(${parseInt(shadowColor.slice(1, 3), 16)}, ${parseInt(shadowColor.slice(3, 5), 16)}, ${parseInt(shadowColor.slice(5, 7), 16)}, ${shadowOpacity / 100})`;
                        boxShadow = `0 ${shadowSize}px ${shadowBlur}px ${rgba}`;
                    }
                    css += `  box-shadow: ${boxShadow};\n`;
                }

                css += '  position: relative;\n';
                css += '  overflow: hidden;\n';
                css += '}\n\n';

                // Inner container
                css += '.image-link-inner {\n';
                if (layout !== 'list') {
                    css += '  display: flex;\n';
                    css += '  flex-direction: column;\n';
                    css += '  height: 100%;\n';
                }
                css += '}\n\n';

                // Images
                css += '.image-link img {\n';
                css += '  display: block;\n';
                css += `  opacity: ${imageOpacity / 100};\n`;
                css += `  transition: all ${transitionSpeed}s ease;\n`;

                // Aspect ratio
                if (layout === 'grid' && displayStyle !== 'masonry' && aspectRatio !== 'auto') {
                    const [w, h] = aspectRatio.split(':');
                    css += `  aspect-ratio: ${w}/${h};\n`;
                }

                // Image fit
                css += `  object-fit: ${imageFit};\n`;

                // Size based on layout
                if (layout === 'grid') {
                    css += '  width: 100%;\n';
                    css += displayStyle === 'masonry' ? '  height: auto;\n' : '  height: 100%;\n';
                } else if (layout === 'list') {
                    css += `  width: ${listImageWidth}px;\n`;
                    css += `  height: ${listImageHeight}px;\n`;
                    css += '  flex-shrink: 0;\n';
                } else {
                    css += '  width: 100%;\n';
                    if (aspectRatio !== 'auto') {
                        const [w, h] = aspectRatio.split(':');
                        css += `  aspect-ratio: ${w}/${h};\n`;
                    }
                }

                css += '}\n\n';

                // Caption
                css += '.image-link-caption {\n';
                css += `  color: ${captionColor};\n`;
                css += `  font-size: ${captionSize}px;\n`;
                css += `  padding: ${captionPadding}px;\n`;
                css += `  text-align: ${captionAlignment};\n`;
                css += `  transition: all ${transitionSpeed}s ease;\n`;

                // Caption position
                if (captionPosition.startsWith('overlay')) {
                    css += '  position: absolute;\n';
                    css += captionPosition === 'overlay-top' ? '  top: 0;\n' : '  bottom: 0;\n';
                    css += '  left: 0;\n';
                    css += '  right: 0;\n';
                    css += `  background-color: ${captionBgColor};\n`;
                } else if (captionPosition === 'hover') {
                    css += '  position: absolute;\n';
                    css += '  top: 0;\n';
                    css += '  left: 0;\n';
                    css += '  right: 0;\n';
                    css += '  bottom: 0;\n';
                    css += '  display: flex;\n';
                    css += '  justify-content: center;\n';
                    css += '  align-items: center;\n';
                    css += `  background-color: ${captionBgColor};\n`;
                    css += '  opacity: 0;\n';
                } else {
                    // Below image
                    css += '  flex-grow: 1;\n';
                    css += `  background-color: ${captionBgColor};\n`;
                }

                // Caption text style
                if (captionTextStyle === 'italic') {
                    css += '  font-style: italic;\n';
                } else if (captionTextStyle === 'uppercase') {
                    css += '  text-transform: uppercase;\n';
                } else if (captionTextStyle === 'smallcaps') {
                    css += '  font-variant: small-caps;\n';
                }

                // Caption custom font
                if (theme.imageLinks.captionFont === 'heading') {
                    css += `  font-family: ${theme.type.headingFont};\n`;
                } else if (theme.imageLinks.captionFont === 'custom' && theme.imageLinks.captionCustomFont) {
                    css += `  font-family: ${theme.imageLinks.captionCustomFont};\n`;
                }

                css += '}\n\n';

                // Add overlay
                if (theme.imageLinks.showOverlayOnHover) {
                    const overlayColor = ThemeUtils.getCurrentColor(theme.imageLinks.overlayColor, mode);

                    css += '.image-link:before {\n';
                    css += '  content: "";\n';
                    css += '  position: absolute;\n';
                    css += '  top: 0;\n';
                    css += '  left: 0;\n';
                    css += '  right: 0;\n';
                    css += '  bottom: 0;\n';
                    css += `  background-color: ${overlayColor};\n`;
                    css += '  opacity: 0;\n';
                    css += `  transition: opacity ${transitionSpeed}s ease;\n`;
                    css += '  z-index: 1;\n';
                    css += '}\n\n';
                }

                return css;
            },

            // Hover effects for image links
            generateImageLinkHoverEffectsCSS(theme, mode) {
                const {
                    imageHoverEffect, hoverEffect, showOverlayOnHover, overlayOpacity,
                    captionPosition, textHoverEffect, transitionSpeed
                } = theme.imageLinks;

                const captionHoverColor = ThemeUtils.getCurrentColor(theme.imageLinks.captionHoverColor, mode);

                let css = '/* Hover effects */\n';

                // Image hover effect
                if (imageHoverEffect !== 'none') {
                    css += '.image-link:hover img {\n';

                    switch (imageHoverEffect) {
                        case 'zoom':
                            css += '  transform: scale(1.1);\n';
                            break;
                        case 'zoom-out':
                            css += '  transform: scale(0.95);\n';
                            break;
                        case 'brighten':
                            css += '  filter: brightness(1.2);\n';
                            break;
                        case 'darken':
                            css += '  filter: brightness(0.8);\n';
                            break;
                        case 'saturate':
                            css += '  filter: saturate(1.5);\n';
                            break;
                        case 'desaturate':
                            css += '  filter: saturate(0.5);\n';
                            break;
                        case 'blur':
                            css += '  filter: blur(2px);\n';
                            break;
                        case 'grayscale':
                            css += '  filter: grayscale(1);\n';
                            break;
                        case 'sepia':
                            css += '  filter: sepia(0.7);\n';
                            break;
                    }

                    css += '}\n\n';
                }

                // Container hover effect
                if (hoverEffect !== 'none') {
                    css += '.image-link:hover {\n';

                    switch (hoverEffect) {
                        case 'lift':
                            css += '  transform: translateY(-5px);\n';
                            css += '  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);\n';
                            break;
                        case 'sink':
                            css += '  transform: translateY(3px);\n';
                            break;
                        case 'glow':
                            css += '  box-shadow: 0 0 15px rgba(0, 100, 255, 0.5);\n';
                            break;
                        case 'shadow':
                            css += '  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);\n';
                            break;
                        case 'border':
                            css += `  border-color: ${captionHoverColor};\n`;
                            break;
                    }

                    css += '}\n\n';
                }

                // Overlay hover effect
                if (showOverlayOnHover) {
                    css += '.image-link:hover:before {\n';
                    css += `  opacity: ${overlayOpacity / 100};\n`;
                    css += '}\n\n';
                }

                // Caption hover
                if (captionPosition === 'hover') {
                    css += '.image-link:hover .image-link-caption {\n';
                    css += '  opacity: 1;\n';
                    css += '}\n\n';
                }

                // Text hover effect
                if (textHoverEffect !== 'none') {
                    css += '.image-link:hover .image-link-caption {\n';
                    css += `  color: ${captionHoverColor};\n`;

                    if (textHoverEffect === 'underline') {
                        css += '  text-decoration: underline;\n';
                    } else if (textHoverEffect === 'bold') {
                        css += '  font-weight: bold;\n';
                    }

                    css += '}\n\n';
                }

                return css;
            },

            // Responsive styles for image links
            generateImageLinkResponsiveCSS(theme, mode) {
                const { layout, displayStyle, gap, spacing } = theme.imageLinks;

                let css = '/* Responsive adjustments */\n';

                // Tablet styles
                css += '@media (max-width: 768px) {\n';
                css += '  .image-link-block {\n';

                if (layout === 'grid') {
                    if (displayStyle === 'masonry') {
                        css += '  }\n';
                        css += '  .image-link {\n';
                        css += `    width: calc(50% - ${gap}px);\n`;
                    } else {
                        css += '    grid-template-columns: repeat(2, 1fr);\n';
                    }
                } else if (layout === 'carousel') {
                    css += `    flex: 0 0 calc((100% / 2) - ${spacing / 2}px);\n`;
                }

                css += '  }\n';
                css += '}\n\n';

                // Mobile styles
                css += '@media (max-width: 480px) {\n';
                css += '  .image-link-block {\n';

                if (layout === 'grid') {
                    if (displayStyle === 'masonry') {
                        css += '  }\n';
                        css += '  .image-link {\n';
                        css += `    width: calc(100% - ${gap}px);\n`;
                    } else {
                        css += '    grid-template-columns: 1fr;\n';
                    }
                } else if (layout === 'carousel') {
                    css += `    flex: 0 0 calc(100% - ${spacing}px);\n`;
                } else if (layout === 'list') {
                    css += '    flex-direction: column;\n';
                }

                css += '  }\n';

                if (layout === 'list') {
                    css += '  .image-link {\n';
                    css += '    flex-direction: column;\n';
                    css += '  }\n';

                    css += '  .image-link img {\n';
                    css += '    width: 100%;\n';
                    css += '    height: auto;\n';
                    css += '    max-height: 200px;\n';
                    css += '    object-fit: cover;\n';
                    css += '  }\n';
                }

                css += '}\n';

                return css;
            },


            // Generate Advanced CSS
            generateAdvancedCSS(theme, mode) {
                let css = '/* Responsive Adjustments */\n';

                // Add responsive media queries
                css += '@media (max-width: 768px) {\n';
                css += '  .page-container {\n';
                css += '    margin: 20px;\n';
                css += '  }\n';

                css += '  .content {\n';
                css += '    padding: 20px;\n';
                css += '  }\n';

                css += '  .hero-panel {\n';
                css += '    padding: 30px 20px;\n';
                css += '  }\n';

                css += '  .image-link-block {\n';
                css += '    grid-template-columns: repeat(2, 1fr);\n';
                css += '  }\n';
                css += '}\n\n';

                css += '@media (max-width: 480px) {\n';
                css += '  .page-container {\n';
                css += '    margin: 10px;\n';
                css += '  }\n';

                css += '  .content {\n';
                css += '    padding: 15px;\n';
                css += '  }\n';

                css += '  .hero-panel {\n';
                css += '    padding: 20px 15px;\n';
                css += '  }\n';

                css += '  .image-link-block {\n';
                css += '    grid-template-columns: 1fr;\n';
                css += '  }\n';
                css += '}\n';

                return css;
            },

            // Generate other CSS section methods
            // ...
        };

        // Theme import/export utilities
        const ThemeIO = {
            // Export CSS with theme JSON embedded as comment
            exportCSS(theme, mode = 'light') {
                const themeJSON = JSON.stringify(theme, null, 2);
                const carouselNote = theme.imageLinks.layout === 'carousel' ?
                    `/*
      Carousel Note:
      The carousel uses CSS scroll-snap for smooth scrolling.
      For enhanced user experience, add the minimal JavaScript 
      included in the HTML demo.
    */` : '';
                const jsonComment = `/*
        BlackQuartz 2.0 Theme Settings
        --------------------------
        Copy the JSON below to save your theme or reimport it later:
        
        START_BLACKQUARTZ_THEME
        ${themeJSON}
        END_BLACKQUARTZ_THEME
        --------------------------
        */
        ${carouselNote}
        `;

                // Add the comment to the top of the CSS
                const css = jsonComment + CSSGenerator.generateCSS(theme, mode);

                return css;
            },

            // Export HTML demo
            exportHTML(theme, cssCode, htmlContent) {
                const carouselNote = theme.imageLinks.layout === 'carousel' ?
                    '<!-- Note: The carousel uses minimal JavaScript for navigation. You can remove it for a CSS-only experience with reduced functionality. -->' : '';

                return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>BlackQuartz 2.0 Theme Demo</title>
      ${theme.loadedFonts.map(font => `<link href="${font}" rel="stylesheet">`).join('\n')}
      <style>${cssCode}</style>
    </head>
    <body>
      ${carouselNote}
      ${htmlContent}
    </body>
    </html>
  `;
            },

            // Other export/import methods...
        };

        // Theme presets and utilities
        const ThemePresets = {
            // Default theme (starting point)
            defaultTheme() {
                return {
                    // Responsive preview settings
                    responsivePreview: {
                        enabled: false,
                        device: 'desktop' // 'desktop', 'tablet', 'mobile'
                    },

                    // Content settings
                    content: {
                        source: 'lorem', // 'lorem', 'wiki'
                        loremParagraphs: 5,
                        loremImages: 3,
                        loremHeadings: 3
                    },

                    // Background settings
                    backgrounds: {
                        body: {
                            type: 'color',
                            color: {
                                light: '#ffffff',
                                dark: '#121212'
                            },
                            gradient: {
                                type: 'linear',
                                angle: 135,
                                stops: [
                                    { color: { light: '#ffffff', dark: '#121212' }, position: 0 },
                                    { color: { light: '#f5f5f5', dark: '#2d2d2d' }, position: 100 }
                                ]
                            },
                            pattern: {
                                id: 'solid',
                                colors: [
                                    { light: '#ffffff', dark: '#121212' },
                                    { light: '#f5f5f5', dark: '#2d2d2d' }
                                ],
                                scale: 20,
                                angle: 0
                            },
                            texture: {
                                id: 'paper',
                                baseColor: { light: '#ffffff', dark: '#121212' },
                                textureColor: { light: '#f5f5f5', dark: '#2d2d2d' },
                                scale: 100,
                                opacity: 50
                            },
                            image: {
                                url: '',
                                size: 'cover',
                                scale: 100,
                                position: 'center center',
                                repeat: 'no-repeat',
                                attachment: 'scroll'
                            },
                            overlay: {
                                enabled: false,
                                color: { light: '#000000', dark: '#ffffff' },
                                opacity: 30
                            }
                        },
                        page: {
                            type: 'color',
                            color: {
                                light: '#ffffff',
                                dark: '#1f1f1f'
                            },
                            overlay: {
                                enabled: false,
                                color: { light: '#000000', dark: '#ffffff' },
                                opacity: 30
                            }
                        },
                        hero: {
                            type: 'color',
                            color: {
                                light: '#f8f9fa',
                                dark: '#343a40'
                            },
                            overlay: {
                                enabled: false,
                                color: { light: '#000000', dark: '#ffffff' },
                                opacity: 30
                            }
                        },

                    },

                    // Page settings
                    page: {
                        enabled: true,
                        shadowSize: 10,
                        borderSize: 1,
                        borderColor: { light: '#dddddd', dark: '#444444' },
                        paddingX: 40,
                        paddingY: 40,
                        maxWidth: 1000,
                        borderRadius: 10
                    },

                    // Typography settings
                    type: {
                        bodyFont: "'Inter', sans-serif",
                        headingFont: "'Inter', sans-serif",
                        lineHeight: 1.6,
                        textSize: 16,
                        textColor: { light: '#333333', dark: '#f5f5f5' },
                        titleSize: 36,
                        titleStyle: 'normal',
                        titleAlign: 'left',
                        titleColor: { light: '#111111', dark: '#ffffff' },
                        titlePaddingX: 0,
                        titlePaddingY: 0,
                        titleSpaceBelow: 30,
                        headingSize: 24,
                        headingStyle: 'normal',
                        headingColor: { light: '#222222', dark: '#f0f0f0' },
                        headingSpaceAbove: 30,
                        headingSpaceBelow: 20,
                        linkColor: { light: '#0066cc', dark: '#4da6ff' },
                        linkHoverColor: { light: '#004080', dark: '#80bdff' },
                        linkUnderline: false,
                        linkHoverEffect: 'underline'
                    },

                    // Hero panel settings
                    hero: {
                        enabled: false,
                        paddingX: 60,
                        paddingY: 60,
                        borderRadius: 0,
                        titleEffect: 'none'
                    },

                    // Inside ThemePresets.defaultTheme(), update the images section:
                    images: {
                        maxWidth: 100,
                        defaultAlign: 'center',
                        borderSize: 1,
                        borderStyle: 'solid',
                        borderColor: { light: '#dddddd', dark: '#444444' },
                        borderRadius: 5,
                        shadowEnabled: true,
                        shadowSize: 10,
                        shadowBlur: 15,
                        shadowOpacity: 25,
                        marginTop: 20,
                        marginBottom: 20,
                        padding: 0,
                        captionEnabled: true,
                        captionPosition: 'below',
                        captionFont: 'inherit',
                        captionSize: 14,
                        captionStyle: 'italic',
                        captionAlign: 'center',
                        captionColor: { light: '#666666', dark: '#bbbbbb' },
                        captionBgEnabled: false,
                        captionBgColor: { light: '#f5f5f5', dark: '#333333' },
                        captionBgOpacity: 80,
                        brightness: 100,
                        contrast: 100,
                        saturation: 100,
                        hoverEffect: 'none'
                    },

                    // Section settings
                    sections: {
                        dividerType: 'line',
                        dividerColor: { light: '#dddddd', dark: '#444444' },
                        dividerWidth: 100,
                        dividerThickness: 1,
                        spaceAbove: 40,
                        spaceBelow: 40
                    },

                    // Blockquote settings
                    blockquote: {
                        style: 'border',
                        borderSize: 4,
                        borderPosition: 'left',
                        borderColor: { light: '#dddddd', dark: '#444444' },
                        backgroundColor: { light: '#f9f9f9', dark: '#2d2d2d' },
                        textColor: { light: '#666666', dark: '#bbbbbb' },
                        fontStyle: 'italic',
                        paddingX: 20,
                        paddingY: 10,
                        spaceAbove: 20,
                        spaceBelow: 20
                    },

                    // Table settings
                    table: {
                        style: 'simple',
                        borderType: 'all',
                        borderSize: 1,
                        borderColor: { light: '#dddddd', dark: '#444444' },
                        headerBackground: { light: '#f5f5f5', dark: '#333333' },
                        headerTextColor: { light: '#333333', dark: '#f5f5f5' },
                        rowBackground: { light: '#ffffff', dark: '#1f1f1f' },
                        altRowBackground: { light: '#f9f9f9', dark: '#2d2d2d' },
                        cellPaddingX: 10,
                        cellPaddingY: 8,
                        spaceAbove: 20,
                        spaceBelow: 20
                    },

                    // List settings
                    list: {
                        style: 'simple',
                        bulletColor: { light: '#333333', dark: '#f5f5f5' },
                        bulletType: 'default',
                        markerPosition: 'outside',
                        itemSpacing: 8,
                        nestedIndent: 20
                    },

                    // Image link settings
                    // Inside the ThemePresets.defaultTheme() function
                    imageLinks: {
                        // Layout settings
                        layout: 'grid',
                        displayStyle: 'standard',
                        itemsPerRow: 3,
                        imagePosition: 'left',
                        spacing: 20,
                        gap: 15,
                        aspectRatio: '4:3',

                        // Border and shadow
                        borderSize: 0,
                        borderColor: { light: '#dddddd', dark: '#444444' },
                        borderStyle: 'solid',
                        borderRadius: 5,
                        shadowStyle: 'none',
                        shadowSize: 10,
                        shadowBlur: 15,
                        shadowColor: { light: '#000000', dark: '#000000' },
                        shadowOpacity: 30,

                        // Background
                        backgroundColor: { light: '#ffffff', dark: '#222222' },

                        // Image settings
                        imageFit: 'cover',
                        imageOpacity: 100,
                        imageHoverEffect: 'zoom',

                        // Caption settings
                        captionPosition: 'below',
                        captionSize: 14,
                        captionColor: { light: '#333333', dark: '#f5f5f5' },
                        captionHoverColor: { light: '#0066cc', dark: '#66b3ff' },
                        captionBackground: { light: 'rgba(255,255,255,0.8)', dark: 'rgba(0,0,0,0.7)' },
                        captionOpacity: 100,
                        captionFont: 'inherit',
                        captionCustomFont: '',
                        captionTextStyle: 'normal',
                        captionAlignment: 'left',
                        captionPadding: 10,

                        // Hover effects
                        hoverEffect: 'none',
                        showOverlayOnHover: false,
                        overlayColor: { light: '#000000', dark: '#ffffff' },
                        overlayOpacity: 50,
                        overlayContent: 'caption',
                        textHoverEffect: 'none',
                        transitionSpeed: 0.3,

                        // Carousel specific
                        carousel: {
                            autoScroll: false,
                            scrollSpeed: 3,
                            showArrows: true,
                            showDots: true,
                            infiniteLoop: true,
                            transition: 'slide'
                        },

                        // List specific
                        list: {
                            imageWidth: 100,
                            imageHeight: 70,
                            showDivider: false,
                            dividerColor: { light: '#eeeeee', dark: '#333333' }
                        }
                    },

                    // Loaded fonts tracking
                    loadedFonts: []
                };
            },

            // Other preset themes
            // ...
        };

        // Main application
        const app = new Vue({
            el: '#app',
            data: {
                // Theme data structure - holds all theme settings
                theme: ThemePresets.defaultTheme(),

                // Editor state - holds UI state not directly related to the theme
                editorState: {
                    activeTab: 'design',
                    isLoading: false,
                    colorMode: 'light',
                    collapsedGroups: {
                        contentSource: false,
                        background: false,
                        page: false,
                        typography: false,
                        hero: false,
                        images: false,
                        sections: false,
                        blockquote: true,
                        table: true,
                        list: true,
                        imageLinks: false,
                        advanced: true
                    },

                    // Background editor state
                    showBackgroundEditor: false,
                    currentBackgroundTarget: 'body',
                    tempBackground: null,

                    // Font selector state
                    showFontSelector: false,
                    fontSelectorTarget: 'body',
                    fontSelectorTab: 'popular',
                    fontSearch: '',
                    tempFontFamily: '',

                    // Color picker state
                    showColorPicker: false,
                    colorPickerTarget: '',
                    tempColor: null,

                    // Wiki state
                    wiki: {
                        search: '',
                        searching: false,
                        error: null,
                        results: [],
                        currentArticle: null,
                        content: null
                    },

                    // Content generation
                    loremTextCache: null
                }
            },
            computed: {
                css() {
                    return CSSGenerator.generateCSS(this.theme, this.editorState.colorMode);
                },
                isLoading() {
                    return this.editorState.isLoading;
                },
                loadedFonts() {
                    // Check if theme and theme.type exist
                    if (!this.theme || !this.theme.type) {
                        return [];
                    }

                    // Get unique fonts that need to be loaded
                    const bodyFont = (this.theme.type.bodyFont || "'Inter', sans-serif").split("'")[1];
                    const headingFont = (this.theme.type.headingFont || "'Inter', sans-serif").split("'")[1];

                    let fontList = [bodyFont];
                    if (headingFont !== bodyFont) {
                        fontList.push(headingFont);
                    }

                    return fontList.map(font =>
                        `https://fonts.googleapis.com/css2?family=${font.replace(/ /g, '+')}:wght@400;700&display=swap`
                    );
                }
            },
            methods: {
                // Background editor methods

                // Background editor methods
                // TODO: Should have a separate thing to fill in all required fields!
                openBackgroundEditor(target) {
                    this.editorState.currentBackgroundTarget = target;

                    // Create default background structure if missing
                    const defaultBackground = {
                        type: 'color',
                        color: {
                            light: '#ffffff',
                            dark: '#121212'
                        },
                        gradient: {
                            type: 'linear',
                            angle: 135,
                            stops: [
                                { color: { light: '#ffffff', dark: '#121212' }, position: 0 },
                                { color: { light: '#f5f5f5', dark: '#2d2d2d' }, position: 100 }
                            ]
                        },
                        pattern: {
                            id: 'solid',
                            colors: [
                                { light: '#ffffff', dark: '#121212' },
                                { light: '#f5f5f5', dark: '#2d2d2d' }
                            ],
                            scale: 20,
                            angle: 0
                        },
                        texture: {
                            id: 'paper',
                            baseColor: { light: '#ffffff', dark: '#121212' },
                            textureColor: { light: '#f5f5f5', dark: '#2d2d2d' },
                            scale: 100,
                            opacity: 50
                        },
                        image: {
                            url: '',
                            size: 'cover',
                            scale: 100,
                            position: 'center center',
                            repeat: 'no-repeat',
                            attachment: 'scroll'
                        },
                        overlay: {
                            enabled: false,
                            color: { light: '#000000', dark: '#ffffff' },
                            opacity: 30
                        }
                    };

                    // Initialize backgrounds object if it doesn't exist
                    if (!this.theme.backgrounds) {
                        this.theme.backgrounds = {};
                    }

                    // Make sure the target background exists with all required properties
                    if (!this.theme.backgrounds[target]) {
                        this.theme.backgrounds[target] = JSON.parse(JSON.stringify(defaultBackground));
                    } else {
                        // Ensure all properties exist (in case of partial initialization)
                        const currentBg = this.theme.backgrounds[target];

                        // Make sure type exists
                        if (!currentBg.type) {
                            currentBg.type = 'color';
                        }

                        // Ensure color object exists
                        if (!currentBg.color) {
                            currentBg.color = defaultBackground.color;
                        }

                        // Ensure gradient object exists
                        if (!currentBg.gradient) {
                            currentBg.gradient = defaultBackground.gradient;
                        }

                        // Ensure pattern object exists
                        if (!currentBg.pattern) {
                            currentBg.pattern = defaultBackground.pattern;
                        }

                        // Ensure texture object exists
                        if (!currentBg.texture) {
                            currentBg.texture = defaultBackground.texture;
                        }

                        // Ensure image object exists
                        if (!currentBg.image) {
                            currentBg.image = defaultBackground.image;
                        }

                        // Ensure overlay object exists
                        if (!currentBg.overlay) {
                            currentBg.overlay = defaultBackground.overlay;
                        }
                    }

                    // Clone the current background settings to temp
                    this.editorState.tempBackground = JSON.parse(JSON.stringify(this.theme.backgrounds[target]));

                    // Show the editor
                    this.editorState.showBackgroundEditor = true;
                },


                saveBackgroundSettings(background) {
                    // Apply the temp settings to the actual background
                    this.theme.backgrounds[this.editorState.currentBackgroundTarget] = JSON.parse(JSON.stringify(background));

                    // Close the editor
                    this.editorState.showBackgroundEditor = false;

                    // Update the preview
                    this.updatePreview();
                },

                // Font selector methods
                openFontSelector(target) {
                    this.editorState.fontSelectorTarget = target;
                    this.editorState.fontSelectorTab = 'popular';
                    this.editorState.fontSearch = '';

                    // Set the initial font based on target
                    if (target === 'body') {
                        this.editorState.tempFontFamily = this.theme.type.bodyFont;
                    } else {
                        this.editorState.tempFontFamily = this.theme.type.headingFont;
                    }

                    this.editorState.showFontSelector = true;
                },

                selectFont(font) {
                    this.editorState.tempFontFamily = `'${font.family}', ${font.category}`;
                },

                applyFontPairing(pairing) {
                    if (this.editorState.fontSelectorTarget === 'body') {
                        this.editorState.tempFontFamily = pairing.body;
                        this.theme.type.headingFont = pairing.heading;
                    } else {
                        this.editorState.tempFontFamily = pairing.heading;
                        this.theme.type.bodyFont = pairing.body;
                    }
                },

                saveFontSelection() {
                    if (this.editorState.fontSelectorTarget === 'body') {
                        this.theme.type.bodyFont = this.editorState.tempFontFamily;
                    } else {
                        this.theme.type.headingFont = this.editorState.tempFontFamily;
                    }

                    this.editorState.showFontSelector = false;
                    this.updatePreview();
                },

                // Color picker methods
                openColorPicker(target) {
                    this.editorState.colorPickerTarget = target;

                    // Set initial color based on target
                    if (target === 'text') {
                        this.editorState.tempColor = this.theme.type.textColor;
                    } else if (target === 'title') {
                        this.editorState.tempColor = this.theme.type.titleColor;
                    } else if (target === 'heading') {
                        this.editorState.tempColor = this.theme.type.headingColor;
                    } else if (target === 'page-border') {
                        this.editorState.tempColor = this.theme.page.borderColor;
                    }

                    this.editorState.showColorPicker = true;
                },

                saveColorSelection(dualColor) {
                    if (this.editorState.colorPickerTarget === 'text') {
                        this.theme.type.textColor = dualColor;
                    } else if (this.editorState.colorPickerTarget === 'title') {
                        this.theme.type.titleColor = dualColor;
                    } else if (this.editorState.colorPickerTarget === 'heading') {
                        this.theme.type.headingColor = dualColor;
                    } else if (this.editorState.colorPickerTarget === 'page-border') {
                        this.theme.page.borderColor = dualColor;
                    }

                    this.editorState.showColorPicker = false;
                    this.updatePreview();
                },

                // Content methods
                toggleGroup(groupName) {
                    this.editorState.collapsedGroups[groupName] = !this.editorState.collapsedGroups[groupName];
                },

                generateNewLorem() {
                    this.editorState.loremTextCache = null;
                    this.generateLoremTextCache();
                    this.updatePreview();
                },

                generateLoremTextCache() {
                    // Generate and cache lorem text so it doesn't change when design changes
                    const paragraphs = [];

                    // First paragraph always starts with the requested text
                    paragraphs.push("Sphinx of black quartz, judge my vow! " + this.getLoremText());

                    // Generate remaining paragraphs
                    for (let i = 1; i < 20; i++) {
                        paragraphs.push(this.getLoremText());
                    }

                    this.editorState.loremTextCache = paragraphs;
                },

                getLoremText() {
                    const loremTexts = [
                        "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam vehicula ipsum a arcu cursus vitae congue mauris rhoncus. Aenean et justo at enim pulvinar malesuada.",
                        "Vestibulum sed arcu non odio euismod lacinia at quis risus. Semper quis lectus nulla at volutpat diam ut venenatis tellus. Bibendum est ultricies integer quis auctor.",
                        "Faucibus interdum posuere lorem ipsum dolor sit amet consectetur adipiscing. Platea dictumst vestibulum rhoncus est pellentesque elit ullamcorper dignissim cras.",
                        "Amet porttitor eget dolor morbi non arcu risus quis varius. Ut enim blandit volutpat maecenas volutpat blandit aliquam etiam erat velit.",
                        "Cras fermentum odio eu feugiat pretium nibh ipsum consequat. Magna etiam tempor orci eu lobortis elementum nibh tellus molestie nunc.",
                        "Ultricies tristique nulla aliquet enim tortor at auctor urna nunc. Semper auctor neque vitae tempus quam pellentesque nec nam aliquam.",
                        "Proin sagittis nisl rhoncus mattis rhoncus urna neque viverra justo. Imperdiet proin fermentum leo vel orci porta non pulvinar neque."
                    ];

                    // Return a random lorem text
                    return loremTexts[Math.floor(Math.random() * loremTexts.length)];
                },

                // Wikipedia search
                searchWikipedia: ThemeUtils.debounce(function (query) {
                    if (query.length < 3) {
                        this.editorState.wiki.results = [];
                        return;
                    }

                    this.editorState.wiki.searching = true;
                    this.editorState.wiki.error = null;

                    try {
                        const url = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(query)}&format=json&origin=*`;
                        fetch(url)
                            .then(response => response.json())
                            .then(data => {
                                if (data.query && data.query.search) {
                                    this.editorState.wiki.results = data.query.search;
                                } else {
                                    this.editorState.wiki.results = [];
                                    this.editorState.wiki.error = "No results found";
                                }
                                this.editorState.wiki.searching = false;
                            })
                            .catch(error => {
                                this.editorState.wiki.error = "Error searching Wikipedia: " + error.message;
                                this.editorState.wiki.results = [];
                                this.editorState.wiki.searching = false;
                            });
                    } catch (error) {
                        this.editorState.wiki.error = "Error searching Wikipedia: " + error.message;
                        this.editorState.wiki.results = [];
                        this.editorState.wiki.searching = false;
                    }
                }, 500),

                selectWikiArticle(article) {
                    this.editorState.wiki.currentArticle = article;
                    this.editorState.wiki.results = [];
                },

                async fetchWikiArticleContent() {
                    if (!this.editorState.wiki.currentArticle) return;

                    this.editorState.isLoading = true;

                    try {
                        // Fetch article extract
                        const extractUrl = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(this.editorState.wiki.currentArticle.title)}?origin=*`;
                        const extractResponse = await fetch(extractUrl);
                        const extractData = await extractResponse.json();

                        // Fetch mobile HTML for sections
                        const mobileHtmlUrl = `https://en.wikipedia.org/api/rest_v1/page/mobile-html/${encodeURIComponent(this.editorState.wiki.currentArticle.title)}?origin=*`;
                        const response = await fetch(mobileHtmlUrl);
                        const html = await response.text();

                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, "text/html");

                        // Get sections from HTML
                        const sectionElements = doc.querySelectorAll("section");
                        const sections = Array.from(sectionElements).map(section => {
                            const heading = section.querySelector("h2, h3, h4, h5, h6")?.textContent.trim() || '';
                            return {
                                heading,
                                content: section.innerHTML
                            };
                        });

                        // Process content
                        this.editorState.wiki.content = {
                            title: extractData.title,
                            extract: extractData.extract,
                            thumbnail: extractData.thumbnail?.source,
                            sections: sections
                        };

                        this.updatePreview();
                    } catch (error) {
                        this.editorState.wiki.error = "Error fetching Wikipedia content: " + error.message;
                    } finally {
                        this.editorState.isLoading = false;
                    }
                },

                // Export/Import methods
                exportCSS() {
                    const css = ThemeIO.exportCSS(this.theme, this.editorState.colorMode);

                    const blob = new Blob([css], { type: 'text/css' });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'blackquartz-theme.css';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                },

                exportHTML() {
                    const htmlContent = this.getSampleHTML();
                    const html = ThemeIO.exportHTML(this.theme, this.css, htmlContent);

                    const blob = new Blob([html], { type: 'text/html' });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'blackquartz-demo.html';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                },

                copyCSS() {
                    const tempTextarea = document.createElement('textarea');
                    tempTextarea.value = this.css;
                    document.body.appendChild(tempTextarea);
                    tempTextarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempTextarea);

                    alert('CSS copied to clipboard!');
                },

                exportThemeJSON() {
                    const themeData = JSON.stringify(this.theme, null, 2);
                    const blob = new Blob([themeData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'blackquartz-theme.json';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                },

                importThemeJSON() {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.json,.css';

                    input.onchange = e => {
                        const file = e.target.files[0];
                        if (!file) return;

                        const reader = new FileReader();
                        reader.onload = event => {
                            try {
                                const fileContent = event.target.result;
                                const fileType = file.name.endsWith('.css') ? 'css' : 'json';

                                let themeData;

                                // Extract JSON from CSS file if needed
                                if (fileType === 'css') {
                                    const startMarker = 'START_BLACKQUARTZ_THEME';
                                    const endMarker = 'END_BLACKQUARTZ_THEME';

                                    const startIndex = fileContent.indexOf(startMarker);
                                    const endIndex = fileContent.indexOf(endMarker);

                                    if (startIndex !== -1 && endIndex !== -1) {
                                        const jsonContent = fileContent.substring(startIndex + startMarker.length, endIndex).trim();
                                        themeData = JSON.parse(jsonContent);
                                    } else {
                                        throw new Error('No theme data found in CSS file');
                                    }
                                } else {
                                    themeData = JSON.parse(fileContent);
                                }

                                // Update theme with imported data
                                this.theme = themeData;

                                // Update the preview
                                this.updatePreview();
                            } catch (error) {
                                alert('Error importing theme: ' + error.message);
                            }
                        };
                        reader.readAsText(file);
                    };

                    input.click();
                },

                // Apply preset theme
                applyPreset(preset) {
                    // Create a copy of the current theme
                    const baseTheme = JSON.parse(JSON.stringify(this.theme));

                    // Get preset data
                    let presetData = {};

                    // Apply different preset themes based on preset name
                    switch (preset) {
                        case 'modern':
                            // Modern minimal preset
                            presetData = {
                                backgrounds: {
                                    body: {
                                        type: 'color',
                                        color: { light: '#ffffff', dark: '#121212' }
                                    },
                                    page: {
                                        type: 'color',
                                        color: { light: '#ffffff', dark: '#1f1f1f' }
                                    },
                                    hero: {
                                        type: 'gradient',
                                        gradient: {
                                            type: 'linear',
                                            angle: 135,
                                            stops: [
                                                { color: { light: '#f8fafc', dark: '#0c4a6e' }, position: 0 },
                                                { color: { light: '#f1f5f9', dark: '#0369a1' }, position: 100 }
                                            ]
                                        }
                                    }
                                },
                                page: {
                                    shadowSize: 15,
                                    borderSize: 0,
                                    paddingX: 60,
                                    paddingY: 60,
                                    maxWidth: 900
                                },
                                type: {
                                    bodyFont: "'Inter', sans-serif",
                                    headingFont: "'Inter', sans-serif",
                                    lineHeight: 1.7,
                                    titleColor: { light: '#111827', dark: '#f9fafb' },
                                    headingColor: { light: '#1f2937', dark: '#f1f5f9' },
                                    textColor: { light: '#4b5563', dark: '#d1d5db' },
                                    linkColor: { light: '#2563eb', dark: '#60a5fa' },
                                    linkHoverColor: { light: '#1d4ed8', dark: '#93c5fd' }
                                }
                            };
                            break;

                        case 'dark':
                            // Dark mode preset
                            presetData = {
                                colorMode: 'dark',
                                backgrounds: {
                                    body: {
                                        type: 'gradient',
                                        gradient: {
                                            type: 'linear',
                                            angle: 135,
                                            stops: [
                                                { color: { light: '#f8f9fa', dark: '#111827' }, position: 0 },
                                                { color: { light: '#e9ecef', dark: '#1f2937' }, position: 100 }
                                            ]
                                        }
                                    }
                                },
                                type: {
                                    bodyFont: "'Inter', sans-serif",
                                    headingFont: "'Inter', sans-serif",
                                    lineHeight: 1.8,
                                    titleColor: { light: '#212529', dark: '#f9fafb' },
                                    headingColor: { light: '#343a40', dark: '#f3f4f6' },
                                    headingStyle: 'leftBorder',
                                    textColor: { light: '#495057', dark: '#d1d5db' },
                                    linkColor: { light: '#0d6efd', dark: '#60a5fa' },
                                    linkHoverColor: { light: '#0a58ca', dark: '#93c5fd' }
                                }
                            };
                            break;

                        // Add other presets...
                    }

                    // Merge the preset data with the current theme
                    const mergeTheme = function (target, source) {
                        for (const key in source) {
                            if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                                if (!target[key]) target[key] = {};
                                mergeTheme(target[key], source[key]);
                            } else {
                                target[key] = source[key];
                            }
                        }
                    };

                    mergeTheme(baseTheme, presetData);
                    this.theme = baseTheme;

                    // Update color mode if specified in preset
                    if (presetData.colorMode) {
                        this.editorState.colorMode = presetData.colorMode;
                    }

                    // Update the preview
                    this.updatePreview();
                },

                // Toggle light/dark mode
                toggleColorMode() {
                    this.editorState.colorMode = this.editorState.colorMode === 'light' ? 'dark' : 'light';
                    this.updatePreview();
                },

                // Generate sample HTML for preview
                getSampleHTML() {
                    if (this.theme.content.source === 'lorem') {
                        return this.getLoremHTML();
                    } else if (this.editorState.wiki.content) {
                        return this.getWikiHTML();
                    } else {
                        return this.getDefaultHTML();
                    }
                },
                // Implementation of HTML content generation methods
                getLoremHTML() {
                    const { loremParagraphs, loremImages, loremHeadings } = this.theme.content;

                    // If we haven't generated lorem text yet, do it now
                    if (!this.editorState.loremTextCache) {
                        this.generateLoremTextCache();
                    }

                    const heroPanel = this.theme.hero.enabled ?
                        `<div class="hero-panel">
              <h1 class="post-title">Black Quartz</h1>
          </div>` : '';

                    let content = '';
                    content += !this.theme.hero.enabled ? '<h1 class="post-title">Black Quartz</h1>' : '';

                    // Generate lorem paragraphs interspersed with headings and images
                    const paragraphsPerSection = Math.ceil(loremParagraphs / loremHeadings);
                    const imagesPerSection = Math.ceil(loremImages / loremHeadings);

                    // Add first paragraph (special)
                    content += `<p>${this.editorState.loremTextCache[0]}</p>\n`;

                    for (let i = 0; i < loremHeadings; i++) {
                        if (i > 0) {
                            content += '<hr>\n';
                        }

                        content += `<h2>Section Heading ${i + 1}</h2>\n`;

                        // Add paragraphs and images for this section
                        for (let p = 0; p < paragraphsPerSection; p++) {
                            // Inside getLoremHTML method, replace the current image insertion code with:
                            if (p % 2 === 0 && p < imagesPerSection) {
                                // Add an image with different alignments
                                const width = 600 + (i * 100) % 300;
                                const height = 300 + (p * 50) % 200;
                                const seed = i * 10 + p;

                                // Alternate between left, right, and full alignment
                                const alignment = p % 3 === 0 ? 'left' : p % 3 === 1 ? 'right' : 'full';
                                content += this.getImageHTML(width, height, seed, null, alignment);
                            }

                            // Use cached lorem text
                            const paraIndex = i * paragraphsPerSection + p + 1; // +1 because we used index 0 already
                            if (paraIndex < this.editorState.loremTextCache.length) {
                                content += `<p>${this.editorState.loremTextCache[paraIndex]}</p>\n`;
                            }

                            // Add a subheading halfway through
                            if (p === Math.floor(paragraphsPerSection / 2) && paragraphsPerSection > 2) {
                                content += `<h3>Subsection ${i + 1}.${p + 1}</h3>\n`;
                            }
                        }
                    }

                    content += `<p>Some text with a <a href="#">link</a> to demonstrate link styling. And <a href="#">another link</a> for good measure.</p>`;

                    // Add style examples
                    content += `<h2>Style Examples</h2>\n`;
                    content += `
          <blockquote>
            ${this.editorState.loremTextCache[Math.floor(Math.random() * this.editorState.loremTextCache.length)]}
          </blockquote>
          
          <table>
            <thead>
              <tr>
                <th>Header 1</th>
                <th>Header 2</th>
                <th>Header 3</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Data 1A</td>
                <td>Data 1B</td>
                <td>Data 1C</td>
              </tr>
              <tr>
                <td>Data 2A</td>
                <td>Data 2B</td>
                <td>Data 2C</td>
              </tr>
              <tr>
                <td>Data 3A</td>
                <td>Data 3B</td>
                <td>Data 3C</td>
              </tr>
            </tbody>
          </table>
          
          <h3>Unordered List</h3>
          <ul>
            <li>First item in the list</li>
            <li>Second item in the list</li>
            <li>Third item with a <a href="#">link</a> inside</li>
            <li>Fourth and final item</li>
          </ul>
          
          <h3>Ordered List</h3>
          <ol>
            <li>First numbered item</li>
            <li>Second numbered item</li>
            <li>Third numbered item</li>
          </ol>
        `;

                    content += '<h2>Related Articles</h2>\n';
                    content += this.getImageLinksHTML();

                    return `
          <div class="page-container">
            ${heroPanel}
            <div class="content">
              ${content}
            </div>
          </div>
        `;
                },

                getWikiHTML() {
                    if (!this.editorState.wiki.content) return this.getDefaultHTML();

                    const { title, extract, thumbnail, sections } = this.editorState.wiki.content;

                    const heroPanel = this.theme.hero.enabled ?
                        `<div class="hero-panel">
              <h1 class="post-title">${title}</h1>
          </div>` : '';

                    let content = '';
                    content += !this.theme.hero.enabled ? `<h1 class="post-title">${title}</h1>` : '';

                    // Add a custom lead-in before the extract
                    content += "<p>Sphinx of black quartz, judge my vow!</p> ";

                    // Add intro paragraph
                    content += `<p>${extract}</p>\n`;

                    // Add first image if available
                    if (thumbnail) {
                        content += this.getImageHTML(thumbnail, 800, 400, 1, `${title} thumbnail`);
                    } else {
                        // Placeholder
                        content += this.getImageHTML(800, 400, 1, `${title} illustration`);
                    }

                    // Add sections
                    if (sections && sections.length) {
                        sections.forEach((section, i) => {
                            if (i > 0) {
                                content += '<hr>\n';
                            }

                            // Add section heading if it's not empty or "See also", "References", etc.
                            if (section.heading && !['See also', 'References', 'External links', 'Notes', 'Bibliography'].includes(section.heading)) {
                                content += `<h2>${section.heading}</h2>\n`;

                                // Add section text if available
                                if (section.content) {
                                    // For security, extract just text content
                                    const tempDiv = document.createElement('div');
                                    tempDiv.innerHTML = section.content;
                                    const text = tempDiv.textContent || tempDiv.innerText || '';

                                    if (text.length > 100) {
                                        content += `<p>${text.substring(0, 300)}...</p>\n`;
                                    } else {
                                        content += `<p>${this.getLoremText()}</p>\n`;
                                    }
                                } else {
                                    // Placeholder text
                                    content += `<p>${this.getLoremText()}</p>\n`;
                                }

                                // Add image for some sections
                                if (i % 2 === 0) {
                                    content += this.getImageHTML(700, 350, i + 2, `Illustration related to ${section.heading}`);
                                }
                            }
                        });
                    }

                    content += `<p>Some text with a <a href="#">link</a> to demonstrate link styling. And <a href="#">another link</a> for good measure.</p>`;

                    // Add sample content to show styling
                    content += '<h2>Related Articles</h2>\n';
                    content += this.getImageLinksHTML();

                    return `
          <div class="page-container">
            ${heroPanel}
            <div class="content">
              ${content}
            </div>
          </div>
        `;
                },

                getDefaultHTML() {
                    // Default content shown when no content source is selected
                    const heroPanel = this.theme.hero.enabled ?
                        `<div class="hero-panel">
              <h1 class="post-title">BlackQuartz 2.0 Theme Designer</h1>
          </div>` : '';

                    return `
          <div class="page-container">
            ${heroPanel}
            <div class="content">
              ${!this.theme.hero.enabled ? '<h1 class="post-title">BlackQuartz 2.0 Theme Designer</h1>' : ''}
              <p>Select a content source in the Content tab to show preview content.</p>
              <p>You can choose between Lorem Ipsum text or search for a Wikipedia article.</p>
              <p>This demo shows all the styling capabilities of your theme. The changes you make in the Design tab will be reflected here.</p>
              
              <h2>Style Examples</h2>
              <p>Here are some basic style examples to get you started:</p>
              
              <h3>Typography</h3>
              <p>This is a paragraph with <a href="#">a sample link</a> to demonstrate link styling.</p>
              
              <h3>Table Example</h3>
              <table>
                <thead>
                  <tr>
                    <th>Header 1</th>
                    <th>Header 2</th>
                    <th>Header 3</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>Data 1A</td>
                    <td>Data 1B</td>
                    <td>Data 1C</td>
                  </tr>
                  <tr>
                    <td>Data 2A</td>
                    <td>Data 2B</td>
                    <td>Data 2C</td>
                  </tr>
                </tbody>
              </table>
              
              <h3>Lists</h3>
              <ul>
                <li>Unordered list item 1</li>
                <li>Unordered list item 2</li>
                <li>Unordered list item with a <a href="#">link</a></li>
              </ul>
              
              <h3>Blockquote</h3>
              <blockquote>
                This is a blockquote. It can be used to highlight important information or quotes from other sources.
              </blockquote>
              
              <h3>Image Example</h3>
              ${this.getImageHTML(800, 400, 1, "Example image")}
            </div>
          </div>
        `;
                },

                // Helper to generate image HTML with alignment options
                getImageHTML(widthOrUrl, height, seed, caption, alignment = 'full') {
                    // Handle different types of parameters
                    let imgUrl;
                    if (typeof widthOrUrl === 'string' && widthOrUrl.startsWith('http')) {
                        // It's already a URL
                        imgUrl = widthOrUrl;
                    } else {
                        // It's a width, so construct a URL
                        const width = widthOrUrl;
                        imgUrl = `https://picsum.photos/${width}/${height}?random=${seed}`;
                    }

                    caption = caption || `Image caption ${seed}`;

                    // Generate class based on alignment
                    const alignClass = alignment === 'full' ? 'image-full' :
                        alignment === 'left' ? 'image-left' :
                            alignment === 'right' ? 'image-right' : 'image-full';

                    return `
            <div class="image-container ${alignClass}">
            <img src="${imgUrl}" alt="Sample image ${seed}">
            <div class="image-caption">${caption}</div>
            </div>
        `;
                },

                // Generate image links HTML
                getImageLinksHTML() {
                    // Get demo link data
                    const links = this.getImageLinkItems();

                    // Get theme settings
                    const { layout, displayStyle } = this.theme.imageLinks;
                    const isCarousel = layout === 'carousel';

                    // Generate the appropriate HTML based on layout
                    if (isCarousel) {
                        return this.generateCarouselHTML(links);
                    } else {
                        return this.generateStandardLayoutHTML(links, displayStyle);
                    }
                },

                // Sample image links data
                getImageLinkItems() {
                    return [
                        { url: '#post1', image: 'https://picsum.photos/400/250?random=101', title: 'Getting Started with CSS', id: 'item1' },
                        { url: '#post2', image: 'https://picsum.photos/400/350?random=102', title: 'Advanced Typography Techniques', id: 'item2' },
                        { url: '#post3', image: 'https://picsum.photos/400/200?random=103', title: 'Responsive Design Principles', id: 'item3' },
                        { url: '#post4', image: 'https://picsum.photos/400/300?random=104', title: 'Color Theory for Web Designers', id: 'item4' },
                        { url: '#post5', image: 'https://picsum.photos/400/280?random=105', title: 'Web Performance Optimization', id: 'item5' }
                    ];
                },

                // Generate standard grid or list layout HTML
                generateStandardLayoutHTML(links, displayStyle) {
                    const html = `<div class="image-link-block${displayStyle === 'masonry' ? ' masonry-grid' : ''}">\n`;
                    const linksHtml = this.generateLinkItemsHTML(links);

                    return html + linksHtml + '</div>\n';
                },

                // Generate carousel layout HTML with optional controls
                generateCarouselHTML(links) {
                    const { carousel } = this.theme.imageLinks;
                    const showArrows = carousel?.showArrows || false;
                    const showDots = carousel?.showDots || false;
                    const autoScroll = carousel?.autoScroll || false;

                    let html = '<div class="carousel-container">\n';

                    // Main carousel container
                    html += `  <div id="image-carousel" class="image-link-block carousel${autoScroll ? ' auto-scroll' : ''}">\n`;
                    html += this.generateLinkItemsHTML(links);
                    html += '  </div>\n';

                    // Add navigation controls if enabled
                    if (showArrows) {
                        html += this.generateCarouselArrowsHTML(links);
                    }

                    if (showDots) {
                        html += this.generateCarouselDotsHTML(links);
                    }

                    html += '</div>\n';

                    // Add optional JavaScript for enhanced navigation
                    if (showArrows || showDots) {
                        html += this.generateCarouselJavaScript(showArrows, showDots);
                    }

                    return html;
                },

                // Generate HTML for each link item
                generateLinkItemsHTML(links) {
                    const { captionPosition } = this.theme.imageLinks;
                    let html = '';

                    for (const link of links) {
                        html += `  <a href="${link.url}" class="image-link" id="${link.id}">\n`;
                        html += `    <div class="image-link-inner">\n`;

                        // Image
                        html += `      <img src="${link.image}" alt="${link.title}">\n`;

                        // Always render caption element, but with appropriate styling
                        // based on position (regular or hover)
                        html += `      <div class="image-link-caption">${link.title}</div>\n`;

                        html += `    </div>\n`;
                        html += `  </a>\n`;
                    }

                    return html;
                },

                generateCarouselArrowsHTML(links) {
                    // Use first and last item IDs for navigation
                    const firstItemId = links[0].id;
                    const lastItemId = links[links.length - 1].id;

                    return `  <a href="#${firstItemId}" class="carousel-arrow carousel-arrow-left">❮</a>\n` +
                        `  <a href="#${lastItemId}" class="carousel-arrow carousel-arrow-right">❯</a>\n`;
                },

                generateCarouselDotsHTML(links) {
                    let html = '  <div class="carousel-dots">\n';

                    links.forEach(link => {
                        html += `    <div class="carousel-dot"><a href="#${link.id}"></a></div>\n`;
                    });

                    html += '  </div>\n';
                    return html;
                },

                generateCarouselJavaScript(showArrows, showDots) {
                    let js = '<script>\n';
                    js += '  // Minimal JavaScript for carousel navigation\n';
                    js += '  document.addEventListener("DOMContentLoaded", function() {\n';
                    js += '    const carousel = document.getElementById("image-carousel");\n';
                    js += '    const items = carousel.querySelectorAll(".image-link");\n';
                    js += '    let currentIndex = 0;\n\n';

                    // Arrow navigation
                    if (showArrows) {
                        js += this.generateArrowNavigationJS();
                    }

                    // Dot navigation
                    if (showDots) {
                        js += this.generateDotNavigationJS();
                    }

                    js += '  }); </' + 'script> \n ';
                    return js;
                },

            // Generate JavaScript for arrow navigation
            generateArrowNavigationJS() {
                return ' const prevBtn = document.querySelector(".carousel-arrow-left");\n' +
                    ' const nextBtn = document.querySelector(".carousel-arrow-right");\n\n' +
                    ' if (prevBtn) {\n' +
                    ' prevBtn.addEventListener("click", function(e) {\n' +
                    ' e.preventDefault();\n' +
                    ' currentIndex = (currentIndex > 0) ? currentIndex - 1 : items.length - 1;\n' +
                    ' items[currentIndex].scrollIntoView({ behavior: "smooth", inline: "start" });\n' +
                    ' });\n' +
                    ' }\n\n' +
                    ' if (nextBtn) {\n' +
                    ' nextBtn.addEventListener("click", function(e) {\n' +
                    ' e.preventDefault();\n' +
                    ' currentIndex = (currentIndex < items.length - 1) ? currentIndex + 1 : 0;\n' +
                    '        items[currentIndex].scrollIntoView({ behavior: "smooth", inline: "start" });\n' +
                    '      });\n' +
                    '    }\n';
            },
            // Generate JavaScript for dot navigation 
            generateDotNavigationJS() {
                return '    const dots = document.querySelectorAll(".carousel-dot a");\n'
                    + '    dots.forEach(function(dot, index) {\n' + '      dot.addEventListener("click", function(e) {\n'
                    + '        e.preventDefault();\n' + '        currentIndex = index;\n'
                    + '        items[index].scrollIntoView({ behavior: "smooth", inline: "start" });\n' + '      });\n'
                    + '    });\n';
            },
            // Update preview iframe 
            updatePreview() {
                this.editorState.isLoading = true; // Ensure lorem text is generated if needed 
                if (this.theme.content.source === 'lorem' && !this.editorState.loremTextCache) {
                    this.generateLoremTextCache();
                }
                // Generate sample HTML 
                const htmlContent = this.getSampleHTML(); // Generate CSS
                const cssCode = this.css; // Update the preview frame 
                this.$nextTick(() => {
                    this.$refs.preview.updatePreview(cssCode, htmlContent);
                    this.editorState.isLoading = false;
                });
            },
            handleKeyDown(e) {
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    this.exportCSS();
                }
            },
            mounted() {
                // Initialize the theme
                this.theme.loadedFonts = this.loadedFonts || [];

                // Initialize content
                if (this.theme.content && this.theme.content.source === 'lorem') {
                    this.generateLoremTextCache();
                }

                // Initialize the preview
                this.updatePreview();

                // Set up debounced update preview function for responsive changes
                this.$watch('theme.responsivePreview', ThemeUtils.debounce(() => {
                    this.updatePreview();
                }, 300), { deep: true });

                // Watch for color mode changes
                this.$watch('editorState.colorMode', () => {
                    this.updatePreview();
                });

                // Watch for theme changes that should update preview
                this.$watch('theme', ThemeUtils.debounce(() => {
                    this.updatePreview();
                }, 500), { deep: true });

                // Add event listener for Ctrl+S to export CSS
                document.addEventListener('keydown', this.handleKeyDown);


                // Clean up event listener when component is destroyed
                this.$once('hook:beforeDestroy', () => {
                    document.removeEventListener('keydown', this.handleKeyDown);
                });
            },
            }
        });
    </script>
</body>

</html>